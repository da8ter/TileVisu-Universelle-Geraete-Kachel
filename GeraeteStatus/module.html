<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <script src="/icons.js" crossorigin="anonymous"></script>

    <style>
        /* Grundlegende Stildefinitionen für die neue dynamische Variablenliste */

        :root {
            --bildbreite: 40%;
            --bildtransparenz: 1;
            --hintergrundfarbe: rgba(255, 255, 255, 0.95);
            --element-spacing: 8px; /* Einheitlicher vertikaler Abstand zwischen allen Elementen */
        }

        html {
            background-color: var(--hintergrundfarbe);
            overflow: hidden;
        }

        body:before {
            content: '';
            display: block;
            position: fixed;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            background-repeat: no-repeat;
            background-size: cover;
            opacity: var(--bildtransparenz);
            background: var(--background-image, none) center / cover no-repeat;
        }

        body {
            font-family: Arial, sans-serif;
        }

        .hidden {
            display: none;
        }

        .visible {
            display: block;
        }

        .main_container {
            width: 100%;
            max-width: 100%;
            display: flex;
            flex-wrap: nowrap;
            font-size: 12px;
            justify-content: center;
            box-sizing: border-box;
        }

        .div1 {
            width: var(--bildbreite);
            box-sizing: border-box;
            border-right: 1px solid color-mix(in srgb, var(--accent-color) 50%, transparent);
            padding: 0px 2.5% 5px 0px;
        }

        .div1 img {
            width: 100%;
        }

        .div2 {
            width: 100%;
            box-sizing: border-box;
            padding: 0px 5px 5px 2.5%;
            margin: 0px 0px 0px 0px;
            border-radius: 0px;
        }

        /* Styles für dynamische Variablen */
        .variables-container {
            display: flex;
            flex-direction: column;
            width: 100%;
        }

        .variable-item {
            margin-bottom: var(--element-spacing, 8px); /* Einheitlicher vertikaler Abstand */
            display: flex;
            align-items: center; /* Vertikale Zentrierung aller Inhalte */
            justify-content: flex-start; /* Horizontale Ausrichtung */
            width: 100%;
            min-height: 15px; /* Reduzierte Mindesthöhe für kompaktere Darstellung */
        }
        
        /* Für gruppierte Variablen: Kein width: 100% damit sie nebeneinander passen */
        .variable-group-item .variable-item {
            width: auto;
            margin-bottom: 0;
            margin-top: 0;
        }
        
        /* AUSNAHME: Progress-Balken brauchen volle Breite, auch in Gruppen */
        .variable-group-item .variable-item .progress-container {
            width: 100%;
        }
        
        /* AUSNAHME: Progress-Bar-Container brauchen volle Breite */
        .variable-group-item .variable-progress {
            width: 100%;
            min-width: 100%;
        }
        
        /* Für gruppierte Variablen: Kein min-width bei Labels für kompakte Darstellung */
        .variable-group-item .variable-label {
            min-width: auto;
        }

        .variable-icon {
            margin-right: 5px;
            display: inline-block;
            vertical-align: baseline;
            flex-shrink: 0;
        }

        .variable-label {
            font-weight: bold;
            min-width: 0px;  /* Feste Breite für Labels */
            flex-shrink: 0;
            display: flex;
            align-items: center; /* Vertikale Zentrierung für Labels */
        }

        .variable-value {
            flex-grow: 1;
            text-align: left;
            display: flex;
            align-items: center; /* Vertikale Zentrierung für Values */
        }

        /* Fortschrittsbalken-Styles - verwende zentrale Konfiguration */
        .progress-container {
            margin-bottom: var(--element-spacing, 8px); /* Einheitlicher vertikaler Abstand */
            margin-top: var(--element-spacing, 8px); /* Einheitlicher vertikaler Abstand */
            width: 100%;
            background-color: var(--progress-bar-bg-color, rgba(135, 135, 135, 0.3));
            border-radius: var(--progress-bar-border-radius, 10px);
            overflow: hidden;
            position: relative;
        }

        .progress-bar {
            height: 100%;
            border-radius: var(--progress-bar-border-radius, 10px) 0 0 var(--progress-bar-border-radius, 10px);
            transition: width 0.3s ease;
            background: linear-gradient(to right, var(--progress-color1), var(--progress-color2));
            min-height: var(--progress-bar-height, 20px);
        }

        .progress-text {
            position: absolute;
            top: 1px;
            left: 0;
            right: 0;
            bottom: 0px;
            z-index: 2;
            display: var(--progress-bar-show-text, flex);
            justify-content: space-between;
            align-items: center;
            padding: 0 var(--progress-bar-text-padding, 12px);
            white-space: nowrap;
            overflow: hidden;
        }

        .progress-main-text {
            flex: 1;
            text-align: left;
            margin-right: 8px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .progress-second-variable {
            flex-shrink: 0;
            text-align: right;
            margin-left: 8px;
        }

        /* Spezielle Ausrichtung für Icons in Progress-Balken */
        .progress-text .variable-icon {
            vertical-align: text-bottom;
            align-self: center;
            display: inline-flex;
            align-items: center;
            transform: translateY(-1px); /* Icon 1px höher */
        }

        .no-wrap {
            white-space: nowrap;
        }

        /* Spezielle Styles für verschiedene Variablentypen */
        .variable-text {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        /* Text-Variablen: 5px mehr Top- und Bottom-Margin als andere Darstellungen */
        .variable-text {
            margin: calc(var(--element-spacing, 8px) ) 0;
        }
        
        /* Optionale Grenzlinie unter Textvariablen */
        .variable-item.with-border-line {
            border-bottom: 1px solid color-mix(in srgb, var(--accent-color) 50%, transparent);
            padding-bottom: 0px;
            margin-bottom: 0px;
        }
        
        /* Für Gruppen mit Grenzlinie */
        .variable-group.with-border-line {
            border-bottom: 1px solid color-mix(in srgb, var(--accent-color) 50%, transparent);
            padding-bottom: 0px;
            margin-bottom: 0px;
        }
        
        /* Spezifische Regel für gruppierte Text-Variablen: Überschreibt die 0-Margin-Regel */
        .variable-group-item .variable-item.text-variable {
            margin-bottom: 0px; /* +5px mehr Abstand auch für gruppierte */
            margin-top: 0px; /* +5px mehr Abstand auch für gruppierte */
        }

        .variable-progress {
            width: 100%;
            display: flex;
            align-items: center; /* Vertikale Zentrierung für Progress-Balken */
            justify-content: center; /* Horizontale Zentrierung */
        }

        .variable-button-container {
            margin-bottom: var(--element-spacing, 8px); /* Einheitlicher vertikaler Abstand */
            margin-top: var(--element-spacing, 8px); /* Einheitlicher vertikaler Abstand */
            display: flex;
            align-items: center; /* Vertikale Zentrierung für Button-Container */
            width: 100%;
        }

        /* Button-Styles für Bool-Variablen */
        .variable-button {
            display: inline-flex;
            align-items: center;
            height: var(--progress-bar-height, 20px);
            padding: 0 12px;
            border: none;
            border-radius: var(--progress-bar-border-radius, 10px);
            background-color: #f8f9fa;
            color: #333;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: inherit;
            font-weight: 500;
            user-select: none;
            min-width: 80px;
            justify-content: center;
            box-sizing: border-box;
        }

        /* Multi-Button-Container für Integer-Variablen */
        .variable-multi-button-container {
            display: flex;
            gap: 1px; /* Reduzierter Abstand für Button-Gruppierung */
            align-items: center;
            width: 100%;
        }

        /* Einzelne Buttons in Multi-Button-Container */
        .variable-multi-button {
            display: inline-flex;
            align-items: center;
            height: var(--progress-bar-height, 20px);
            padding: 0 8px;
            border: none;
            border-radius: var(--progress-bar-border-radius, 10px);
            background-color: #f8f9fa;
            color: #333;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: inherit;
            font-weight: 500;
            user-select: none;
            min-width: 60px;
            justify-content: center;
            box-sizing: border-box;
            flex: 0 0 auto; /* Verhindere automatisches Stretching, respektiere explizite Breite */
        }

        .variable-multi-button:hover {
            opacity: 0.8;
        }

        .variable-multi-button.active {
            font-weight: 600;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        /* Button-Gruppierung: Spezielle Border-Radius für zusammenhängende Button-Gruppe */
        .variable-multi-button.first-button {
            border-radius: var(--progress-bar-border-radius, 10px) 0 0 var(--progress-bar-border-radius, 10px); /* Nur links rund */
        }

        .variable-multi-button.middle-button {
            border-radius: 0; /* Keine runden Ecken */
        }

        .variable-multi-button.last-button {
            border-radius: 0 var(--progress-bar-border-radius, 10px) var(--progress-bar-border-radius, 10px) 0; /* Nur rechts rund */
        }

        .variable-multi-button.single-button {
            border-radius: var(--progress-bar-border-radius, 10px); /* Alle Ecken rund wenn nur ein Button */
        }

        
        /* Status-Bereich Styles */
        .status-container {
            margin-bottom: var(--element-spacing, 8px);
            padding: 0px 0;
        }

        .status-label {
            font-weight: bold;
            margin-right: 0px;
        }

        .status-value {
            color: var(--status-color, #000000);
        }

        .status-icon {
            margin-right: 8px;
            width: 16px;
            height: 16px;
        }
    </style>

    <script>
        // Globale Debug-Steuerung für Frontend
        let debugEnabled = false; // Wird über handleMessage gesetzt
        
        /**
         * Zentrale Debug-Funktion für Frontend - alle Debug-Ausgaben laufen über diese Funktion
         * @param {string} message Debug-Nachricht
         * @param {string} category Optional: Kategorie für bessere Übersicht
         */
        function debugLog(message, category = 'TileVisu Frontend') {
            if (debugEnabled) {
                console.log(`[${category}] ${message}`);
            }
        }
        
        // Icons werden direkt vom Server gemappt, wir müssen nur noch die richtigen CSS-Klassen hinzufügen
        
        // Bereite ein Icon für die Verwendung im Frontend vor
        function prepareIconForDisplay(iconName) {
            // Wenn kein Icon oder leerer String, nichts zurückgeben
            if (!iconName || iconName === 'Transparent' || iconName === '') {
                return '';
            }
            
            // Das Icon wurde bereits auf dem Server gemappt, wir müssen nur sicherstellen
            // dass das richtige Präfix vorhanden ist
            let iconClass = iconName;
            
            // Füge fa-light Präfix hinzu wenn nötig
            if (!iconClass.startsWith('fa-')) {
                iconClass = 'fa-fw fa-light fa-' + iconClass;
            } else if (!iconClass.startsWith('fa-light ')) {
                iconClass = 'fa-fw fa-light ' + iconClass;
            }
            
            debugLog('Prepared icon for display: ' + iconName + ' → ' + iconClass, 'prepareIconForDisplay');
            return iconClass;
        }
        
        // Hilfsfunktion zur Bestimmung der Textfarbe
        function getTextColor(variable) {
            // Verwende --content-color wenn TextColor transparent ist, ansonsten die konfigurierte Farbe
            if (variable.isTextColorTransparent) {
                return 'var(--content-color)';
            }
            return variable.textColor;
        }

        // Hilfsfunktion zur Bildanzeige-Steuerung basierend auf Bildauswahl und Bildbreite
        function updateImageVisibility() {
            debugLog('=== updateImageVisibility START ===', 'updateImageVisibility');
            const div1 = document.getElementById('div1');
            const div2 = document.getElementById('div2');
            const mainContainer = document.querySelector('.main_container');
            const bildauswahl = window.currentBildauswahl;
            const bildbreite = window.currentBildbreite;
            debugLog('Current values - bildauswahl: ' + bildauswahl + ' (type: ' + typeof bildauswahl + '), bildbreite: ' + bildbreite + ' (type: ' + typeof bildbreite + ')', 'updateImageVisibility');
            
            // DEBUG: DOM-Elemente prüfen
            debugLog('DOM elements - div1: ' + (div1 ? 'found' : 'NOT FOUND'), 'updateImageVisibility');
            debugLog('DOM elements - div2: ' + (div2 ? 'found' : 'NOT FOUND'), 'updateImageVisibility');
            
            // HINWEIS: bildauswahl === undefined ist normal im neuen per-Assoziation-System
            
            // EXPLICIT NONE CHECK FOR DEBUGGING
            debugLog('updateImageVisibility: Checking if bildauswahl is NONE. Current value: ' + bildauswahl + ' (type: ' + typeof bildauswahl + ')', 'updateImageVisibility');
            if (bildauswahl === 'none') {
                debugLog('*** NONE DETECTED *** bildauswahl is exactly "none" - HIDING IMAGE!', 'updateImageVisibility');
            }
            
            // SEPARATED LOGIC: Column hiding vs Image hiding
            const hideImageColumn = window.hideImageColumn || false;
            const currentImageIsNone = (bildauswahl === 'none');
            
            // Hide ENTIRE COLUMN only when: ALL associations "none" OR bildbreite = 0
            const shouldHideColumn = (
                hideImageColumn ||           // All associations are "none"
                bildbreite === 0 || bildbreite === '0'  // Image width is 0
            );
            
            // Hide just IMAGE (keep column) when: current status is "none"
            const shouldHideImageOnly = currentImageIsNone && !shouldHideColumn;
            
            // DEBUG: Detaillierte Bedingungsprüfung
            debugLog('Condition checks:', 'updateImageVisibility');
            debugLog('  hideImageColumn (all associations none): ' + hideImageColumn, 'updateImageVisibility');
            debugLog('  currentImageIsNone (current status none): ' + currentImageIsNone, 'updateImageVisibility');
            debugLog('  bildauswahl value: ' + bildauswahl, 'updateImageVisibility');
            debugLog('  bildbreite === 0: ' + (bildbreite === 0), 'updateImageVisibility');
            debugLog('  bildbreite === "0": ' + (bildbreite === '0'), 'updateImageVisibility');
            debugLog('  shouldHideColumn (entire column): ' + shouldHideColumn, 'updateImageVisibility');
            debugLog('  shouldHideImageOnly (image only, keep column): ' + shouldHideImageOnly, 'updateImageVisibility');
            
            if (shouldHideColumn) {
                debugLog('*** EXECUTING COLUMN HIDE (entire column) ***', 'updateImageVisibility');
                if (div1) {
                    debugLog('Setting div1.style.display = "none"', 'updateImageVisibility');
                    div1.style.display = 'none';
                    debugLog('Setting div1.className = "hidden"', 'updateImageVisibility');
                    div1.className = 'hidden';
                    debugLog('Current div1.style.display after change: ' + div1.style.display, 'updateImageVisibility');
                } else {
                    debugLog('ERROR: div1 not found, cannot hide column!', 'updateImageVisibility');
                }
                if (div2) {
                    debugLog('Setting div2 single-column layout', 'updateImageVisibility');
                    div2.style.padding = '10px';
                    div2.style.width = '100%'; // div2 nimmt gesamte Breite ein
                } else {
                    debugLog('ERROR: div2 not found, cannot adjust layout!', 'updateImageVisibility');
                }
                debugLog('Column hidden, single-column layout: hideImageColumn=' + hideImageColumn + ', bildbreite=' + bildbreite, 'updateImageVisibility');
            } else if (shouldHideImageOnly) {
                debugLog('*** EXECUTING IMAGE HIDE ONLY (keep column) ***', 'updateImageVisibility');
                if (div1) {
                    debugLog('Keeping div1 visible but hiding image content', 'updateImageVisibility');
                    div1.style.display = 'block';  // Keep column visible
                    div1.className = 'div1';        // Keep normal column class
                    // Hide the actual image element inside div1
                    const imageElement = div1.querySelector('#image');
                    if (imageElement) {
                        imageElement.style.display = 'none';
                        debugLog('Hidden image element inside div1', 'updateImageVisibility');
                    }
                } else {
                    debugLog('ERROR: div1 not found, cannot hide image content!', 'updateImageVisibility');
                }
                if (div2) {
                    debugLog('Keeping div2 two-column layout', 'updateImageVisibility');
                    div2.style.padding = '0px 5px 5px 2.5%'; // Standard two-column padding
                    div2.style.width = '100%';
                } else {
                    debugLog('ERROR: div2 not found, cannot maintain layout!', 'updateImageVisibility');
                }
                debugLog('Image content hidden, two-column layout maintained: bildauswahl=' + bildauswahl, 'updateImageVisibility');
            } else {
                debugLog('*** EXECUTING IMAGE SHOW ***', 'updateImageVisibility');
                if (div1) {
                    debugLog('Setting div1.style.display = "block"', 'updateImageVisibility');
                    div1.style.display = 'block';
                    debugLog('Setting div1.className = "div1"', 'updateImageVisibility');
                    div1.className = 'div1';
                    // Show the image element inside div1
                    const imageElement = div1.querySelector('#image');
                    if (imageElement) {
                        imageElement.style.display = 'block';
                        debugLog('Shown image element inside div1', 'updateImageVisibility');
                    }
                    debugLog('Current div1.style.display after change: ' + div1.style.display, 'updateImageVisibility');
                } else {
                    debugLog('ERROR: div1 not found, cannot show image!', 'updateImageVisibility');
                }
                if (div2) {
                    debugLog('Setting div2 two-column layout', 'updateImageVisibility');
                    div2.style.padding = '0px 5px 5px 2.5%'; // Standard-Padding wiederherstellen
                    div2.style.width = '100%'; // div2 bleibt flexibel
                } else {
                    debugLog('ERROR: div2 not found, cannot adjust layout!', 'updateImageVisibility');
                }
                debugLog('Image shown, two-column layout: bildauswahl=' + bildauswahl + ', bildbreite=' + bildbreite, 'updateImageVisibility');
            }
            debugLog('=== updateImageVisibility END ===', 'updateImageVisibility');
            
            // DEBUG: Final DOM state check
            if (div1) {
                debugLog('FINAL STATE - div1.style.display: ' + div1.style.display, 'updateImageVisibility');
                debugLog('FINAL STATE - div1.className: ' + div1.className, 'updateImageVisibility');
            }
            if (div2) {
                debugLog('FINAL STATE - div2.style.padding: ' + div2.style.padding, 'updateImageVisibility');
                debugLog('FINAL STATE - div2.style.width: ' + div2.style.width, 'updateImageVisibility');
            }
        }

        function updateProgressBarStyles(config) {
            debugLog('Updating progress bar styles with config:', config);
            const root = document.documentElement;
            
            // Setze CSS-Variablen für die zentrale Konfiguration
            root.style.setProperty('--progress-bar-height', config.height + 'px');
            root.style.setProperty('--progress-bar-border-radius', config.borderRadius + 'px');
            
            // Konvertiere Hintergrundfarbe zu rgba mit Transparenz
            const bgColor = config.backgroundColor;
            const opacity = config.backgroundOpacity;
            
            // Extrahiere RGB-Werte aus Hex-Farbe
            const r = parseInt(bgColor.substr(1, 2), 16);
            const g = parseInt(bgColor.substr(3, 2), 16);
            const b = parseInt(bgColor.substr(5, 2), 16);
            const rgbaColor = `rgba(${r}, ${g}, ${b}, ${opacity})`;
            
            root.style.setProperty('--progress-bar-bg-color', rgbaColor);
            root.style.setProperty('--progress-bar-bg-opacity', '1'); // Opacity bereits in rgba enthalten
            // Dynamisches Padding basierend auf Textgröße: Padding = fontSize / 2
            const fontSize = parseInt(getComputedStyle(document.documentElement).fontSize) || 12;
            const dynamicPadding = Math.max(4, Math.round(fontSize / 1)); // Minimum 4px
            root.style.setProperty('--progress-bar-text-padding', dynamicPadding + 'px');
            root.style.setProperty('--progress-bar-show-text', config.showText ? 'flex' : 'none');
        }

        function handleMessage(data) {
            // --- DEBUG: Log all contents of handleMessage input ---
            try {
                debugLog('handleMessage: FULL INPUT (JSON): ' + JSON.stringify(data, null, 2), 'handleMessage');
                if (data && typeof data === 'object') {
                    Object.keys(data).forEach(function(key) {
                        debugLog('handleMessage: Property: ' + key + ' | Value: ' + JSON.stringify(data[key]) + ' | Type: ' + typeof data[key], 'handleMessage');
                    });
                } else {
                    debugLog('handleMessage: data is not an object! Type: ' + typeof data, 'handleMessage');
                }
            } catch (e) {
                debugLog('handleMessage: ERROR while logging input: ' + e, 'handleMessage');
            }
            // --- END DEBUG ---
            debugLog('handleMessage called with raw data: ' + data, 'handleMessage');
            const decodedData = JSON.parse(data);
            debugLog('Decoded data: ' + JSON.stringify(decodedData), 'handleMessage');
            const root = document.documentElement;
            
            // Setze InstanceID für RequestAction-Aufrufe
            if (decodedData.instanceid) {
                window.InstanceID = decodedData.instanceid;
                debugLog('Set window.InstanceID to: ' + window.InstanceID, 'handleMessage');
            }

            // Verarbeite die neuen Parameter
            for (const parameter in decodedData) {
                const value = decodedData[parameter];
                debugLog('Processing parameter: ' + parameter + ' with value: ' + value, 'handleMessage');
                
                switch (parameter.toLowerCase()) {
                    case 'debugenabled':
                        debugEnabled = value;
                        debugLog('Debug mode ' + (value ? 'enabled' : 'disabled'), 'Debug System');
                        break;
                    case 'elementspacing':
                        // Setze CSS-Variable für element-spacing
                        root.style.setProperty('--element-spacing', value + 'px');
                        debugLog('Set element-spacing to: ' + value + 'px', 'handleMessage');
                        break;
                        
                    case 'status':
                    case 'statusvalue':
                    case 'statuscolor':
                    case 'statusBildauswahl':  
                        // Set global currentBildauswahl for updateImageVisibility
                        if (decodedData.hasOwnProperty('statusBildauswahl')) {
                            window.currentBildauswahl = decodedData.statusBildauswahl;
                            debugLog('Global currentBildauswahl now set to: ' + window.currentBildauswahl, 'handleMessage');
                        }
                        renderStatus(decodedData);
                        updateImageVisibility();
                        break;
                    case 'hideimagecolumn':
                        // NEW: Handle hideImageColumn flag for complete image column visibility
                        if (decodedData.hasOwnProperty('hideImageColumn')) {
                            window.hideImageColumn = decodedData.hideImageColumn;
                            debugLog('Global hideImageColumn set to: ' + window.hideImageColumn, 'handleMessage');
                            updateImageVisibility();
                        }
                        break;
                    case 'statusschriftgroesse':
                        renderStatus(decodedData);
                        break;
                    case 'variables':
                        // Speichere Variables-Daten für spätere Verwendung
                        window.lastVariablesData = value;
                        
                        // Rendere nur wenn groupNames bereits verfügbar sind, oder wenn keine Gruppen verwendet werden
                        const hasGroupedVariables = value && value.some(v => v.group && v.group !== 'keine Gruppe' && v.showGroupName);
                        
                        if (!hasGroupedVariables || window.groupNames) {
                            // Keine Gruppen mit showGroupName ODER groupNames sind verfügbar
                            renderVariables(value);
                            debugLog('Variables rendered immediately. hasGroupedVariables: ' + hasGroupedVariables + ', groupNames available: ' + !!window.groupNames);
                        } else {
                            // Warte auf groupNames - wird später von groupNames case gerendert
                            debugLog('Variables rendering delayed - waiting for groupNames');
                        }
                        
                        break;
                    case 'progressbarconfig':
                        updateProgressBarStyles(value);
                        // Nach Progress-Config-Update, re-render Variables wenn nötig
                        if (window.lastVariablesData) {
                            renderVariables(window.lastVariablesData);
                        }
                        break;
                    case 'assets':
                        // Aktualisiere Assets (Bilder) sofort
                        if (typeof value === 'object') {
                            window.assets = window.assets || {};
                            Object.assign(window.assets, value);
                            debugLog('Assets updated:', Object.keys(value));
                        }
                        break;
                    case 'groupnames':
                        // Speichere Gruppennamen für Frontend-Verwendung
                        window.groupNames = value;
                        debugLog('Group names updated: ' + JSON.stringify(value));
                        // Re-render variables wenn bereits geladen, damit neue Gruppennamen angezeigt werden
                        if (window.lastVariablesData) {
                            renderVariables(window.lastVariablesData);
                        }
                        break;
                    case 'bildbreite':
                        root.style.setProperty('--bildbreite', value + '%');
                        debugLog('Setting bildbreite to: ' + value + ' (type: ' + typeof value + ')', 'handleMessage');
                        window.currentBildbreite = value;
                        debugLog('Global bildbreite is now: ' + window.currentBildbreite, 'handleMessage');
                        updateImageVisibility();
                        break;
                    case 'bildtransparenz':
                        root.style.setProperty('--bildtransparenz', value);
                        break;
                    case 'kachelhintergrundfarbe':
                        if (value === '#FFFFFFFFFFFFFFFF') {
                            root.style.setProperty('--hintergrundfarbe', 'rgba(0, 0, 0, 0)');
                        } else {
                            root.style.setProperty('--hintergrundfarbe', value);
                        }
                        break;
                    case 'image1':
                        const mainDiv = document.querySelector('body');
                        mainDiv.style.setProperty('--background-image', 'url(' + value + ')');
                        break;
                    default:
                        debugLog('Processing parameter: ' + parameter + ' with value: ' + value, 'handleMessage');
                        // Prüfe auf Variable-Updates (Parameter endet mit '_value')
                        if (parameter.endsWith('_value')) {
                            debugLog('Variable value update detected: ' + parameter + ' = ' + value, 'handleMessage');
                            
                            // Extrahiere Variable-ID aus Parameter (z.B. 'var_3_value' -> 'var_3')
                            const varKey = parameter.replace('_value', '');
                            debugLog('Looking for button with variable key:', varKey);
                            
                            // Aktualisiere rawValue im Cache
                            if (window.variableDataCache) {
                                const targetVariableId = window.varKeyToIdMapping?.[varKey];
                                if (targetVariableId && window.variableDataCache[targetVariableId]) {
                                    window.variableDataCache[targetVariableId].rawValue = value;
                                    debugLog('Updated raw value in cache for variable:', targetVariableId);
                                }
                            }
                            
                            // Aktualisiere die entsprechende Variable (Button oder Text)
                            updateVariable(varKey, value, 'rawValue');
                        }
                        // Prüfe auf formatierte Werte (Parameter ist z.B. 'var_3')
                        else {
                            debugLog('  - startsWith("var_"):', parameter.startsWith('var_'));
                            debugLog('  - endsWith("_value"):', parameter.endsWith('_value'));
                            debugLog('  - !endsWith("_value"):', !parameter.endsWith('_value'));
                            debugLog('  - both conditions:', parameter.startsWith('var_') && !parameter.endsWith('_value'));
                            if (parameter.startsWith('var_') && !parameter.endsWith('_value')) {
                                debugLog('Formatted value update detected:', parameter, '=', value);
                            
                            // Aktualisiere formatierte Werte im Cache
                            if (window.variableDataCache) {
                                const targetVariableId = window.varKeyToIdMapping?.[parameter];
                                if (targetVariableId && window.variableDataCache[targetVariableId]) {
                                    window.variableDataCache[targetVariableId].formattedValue = value;
                                    debugLog('Updated formatted value in cache for variable:', targetVariableId);
                                    
                                    // Aktualisiere Variable-Darstellung mit neuem formatiertem Wert
                                    updateVariable(parameter, value, 'formattedValue');
                                }
                            }
                            }
                        }
                        break;
                }
            }
        }

        // Universelle Variable-Update-Funktion für gruppierte und einzelne Variablen
        function updateVariable(varKey, newValue, updateType = 'rawValue') {
            debugLog('updateVariable called with varKey:', varKey, 'newValue:', newValue, 'updateType:', updateType);
            
            // Finde Variable-ID aus Mapping
            if (!window.varKeyToIdMapping || !window.varKeyToIdMapping[varKey]) {
                debugLog('No mapping found for varKey:', varKey);
                debugLog('Available mappings:', window.varKeyToIdMapping);
                return;
            }
            
            const targetVariableId = window.varKeyToIdMapping[varKey];
            debugLog('Target variable ID for', varKey, ':', targetVariableId);
            
            // Finde Variable-Daten aus Cache
            if (!window.variableDataCache || !window.variableDataCache[targetVariableId]) {
                debugLog('Variable not found in cache for ID:', targetVariableId);
                return;
            }
            
            const variable = window.variableDataCache[targetVariableId];
            debugLog('Found variable in cache:', variable.id, 'label:', variable.label, 'displayType:', variable.displayType);
            
            // Update cache based on updateType
            if (updateType === 'rawValue') {
                variable.rawValue = newValue;
            } else if (updateType === 'formattedValue') {
                variable.formattedValue = newValue;
            }
            
            // Finde das DOM-Element für diese Variable
            const variableElement = document.querySelector(`[data-variable-id="${targetVariableId}"]`);
            
            if (variable.displayType === 'button' && variableElement) {
                // Button-Update
                updateButtonDisplay(variableElement, variable);
            } else {
                // Text-Variable-Update (auch in Gruppen)
                updateTextDisplay(targetVariableId, variable);
            }
        }
        
        // Hilfsfunktion für Button-Display-Update
        function updateButtonDisplay(buttonElement, variable) {
            debugLog('Updating button display for variable:', variable.id);
            
            // Check if this is a multi-button container (Integer or String variable)
            const multiButtonContainer = buttonElement.querySelector('.variable-multi-button-container');
            
            // Support both Integer (variableType 1) and String (variableType 3) variables
            const associations = variable.variableAssociations || variable.integerAssociations;
            const isButtonVariable = (variable.variableType === 1 || variable.variableType === 3) && associations;
            
            if (multiButtonContainer && isButtonVariable) {
                // Integer/String variable: Update multi-buttons
                const currentValue = variable.variableType === 1 ? parseInt(variable.rawValue) : variable.rawValue;
                const buttons = multiButtonContainer.querySelectorAll('.variable-multi-button');
                
                buttons.forEach(button => {
                    const associationValue = variable.variableType === 1 ? 
                        parseInt(button.getAttribute('data-association-value')) : 
                        button.getAttribute('data-association-value');
                    const isActive = currentValue === associationValue;
                    
                    // Find the corresponding association for color
                    const association = associations.find(assoc => assoc.value === associationValue);
                    const buttonColor = association?.color || 'var(--accent-color)';
                    const opacity = isActive ? '1' : '0.7';
                    
                    // Update button state
                    button.style.backgroundColor = buttonColor;
                    button.style.opacity = opacity;
                    
                    if (isActive) {
                        button.classList.add('active');
                    } else {
                        button.classList.remove('active');
                    }
                });
                
                debugLog('Multi-buttons updated for variable:', variable.id, 'current value:', currentValue);
            } else {
                // Boolean variable: Single button update
                const isActive = variable.rawValue === true || variable.rawValue === 1 || variable.rawValue === '1' || variable.rawValue === 'true';
                const currentBoolValue = isActive; // Use actual boolean value for Association-Matching
                debugLog('Button color update - isActive:', isActive, 'for value:', variable.rawValue, 'currentBoolValue:', currentBoolValue);
                
                // Bool Buttons verwenden ausschließlich boolButtonColor
                let buttonColor = 'var(--accent-color)';
                let associationIcon = null;
                let associationName = null;
                
                // Verwende ausschließlich boolButtonColor für Bool Buttons
                if (variable.isBoolButtonColorTransparent) {
                    buttonColor = 'var(--accent-color)';
                } else {
                    buttonColor = variable.boolButtonColor || 'var(--accent-color)';
                }
                
                debugLog('Bool Button using exclusive boolButtonColor:', {
                    boolButtonColor: variable.boolButtonColor,
                    isTransparent: variable.isBoolButtonColorTransparent,
                    finalColor: buttonColor
                });
                
                // Association-Icon und Name für Bool Buttons (nur für Icon/Name, nicht für Farbe)
                const associations = variable.variableAssociations;
                if (associations && Array.isArray(associations)) {
                    const currentAssociation = associations.find(assoc => assoc.value === currentBoolValue);
                    if (currentAssociation) {
                        associationIcon = currentAssociation.icon;
                        associationName = currentAssociation.name;
                        debugLog('Boolean button using association icon/name only:', {
                            icon: associationIcon,
                            name: associationName
                        });
                    }
                }                
                const opacity = isActive ? '1' : '0.7';
                
                // Aktualisiere Button-Style
                buttonElement.style.backgroundColor = buttonColor;
                // buttonElement.style.borderColor = buttonColor; // Border entfernt
                buttonElement.style.opacity = opacity;
                
                // Button-Inhalt zusammenstellen
                let buttonText = '';
                let iconHtml = '';
                
                // Icon-Verarbeitung für Button-Update - Verwende Association-Icon falls vorhanden
                let finalIcon = associationIcon || variable.icon; // Association-Icon hat Priorität
                if (variable.showIcon && finalIcon && finalIcon !== 'Transparent') {
                    const iconClass = prepareIconForDisplay(finalIcon);
                    if (iconClass) {
                        iconHtml = `<i class="${iconClass}" style="margin-right: 6px;"></i>`;
                    }
                }
                
                let textParts = [];
                if (variable.showIcon && iconHtml) {
                    textParts.push(iconHtml);
                }
                if (variable.showLabel) {
                    // Verwende Variablenname als Priorität, Association-Name als Fallback
                    const displayLabel = variable.label || associationName || (isActive ? 'ON' : 'OFF');
                    textParts.push(displayLabel);
                }
                if (variable.showValue) {
                    textParts.push(variable.formattedValue);
                }
                if (!variable.showIcon && !variable.showLabel && !variable.showValue) {
                    textParts.push(variable.label || (isActive ? 'ON' : 'OFF'));
                }
                
                buttonText = textParts.join(' ');
                if (variable.showIcon && !variable.showLabel && !variable.showValue && iconHtml) {
                    buttonText = iconHtml.replace('margin-right: 6px;', '');
                }
                
                buttonElement.innerHTML = buttonText;
                debugLog('Single button updated successfully for variable:', variable.id);
            }
        }
        
        // Hilfsfunktion für Text- und Progress-Display-Update
        function updateTextDisplay(targetVariableId, variable) {
            debugLog('Updating display for variable:', variable.id, 'displayType:', variable.displayType);
            
            const container = document.getElementById('variables-container');
            if (!container) return;
            
            if (variable.displayType === 'progress') {
                // Progress-Bar-Update
                updateProgressDisplay(targetVariableId, variable);
            } else {
                // Text-Variable-Update
                updateTextVariableDisplay(targetVariableId, variable);
            }
        }
        
        // Hilfsfunktion für Progress-Bar-Update
        function updateProgressDisplay(targetVariableId, variable) {
            debugLog('Updating progress bar for variable:', variable.id);
            
            // Finde Progress-Container mit der entsprechenden Variable-ID
            const progressContainer = document.querySelector(`[data-variable-id="${targetVariableId}"].progress-container`);
            
            if (!progressContainer) {
                debugLog('Progress container not found for variable ID:', targetVariableId);
                return;
            }
            
            debugLog('Found progress container for variable:', variable.id);
            
            // Aktualisiere Progress-Bar-Breite
            const progressBar = progressContainer.querySelector('.progress-bar');
            if (progressBar) {
                // Berechne Prozentsatz basierend auf Min/Max-Werten
                const rawValue = parseFloat(variable.rawValue) || 0;
                const minValue = parseFloat(variable.progressMin) || 0;
                const maxValue = parseFloat(variable.progressMax) || 100;
                
                // Stelle sicher, dass maxValue > minValue
                const range = maxValue - minValue;
                let progressPercent = 0;
                
                if (range > 0) {
                    progressPercent = Math.max(0, Math.min(100, ((rawValue - minValue) / range) * 100));
                }
                
                progressBar.style.width = progressPercent + '%';
                debugLog('Updated progress bar for variable', variable.id + ':', {
                    rawValue: rawValue,
                    minValue: minValue,
                    maxValue: maxValue,
                    progressPercent: progressPercent.toFixed(1) + '%'
                });
            }
            
            // Aktualisiere Progress-Text
            const progressTextContainer = progressContainer.querySelector('.progress-text');
            if (progressTextContainer) {
                updateProgressText(progressTextContainer, variable);
            }
        }
        
        // Hilfsfunktion für Progress-Text-Update
        function updateProgressText(progressTextContainer, variable) {
            debugLog('Updating progress text for variable:', variable.id);
            
            // Progress-Bar Inhalt basierend auf Konfiguration
            let progressIconHtml = '';
            if (variable.showIcon && variable.icon && variable.icon !== 'Transparent') {
                const iconClass = prepareIconForDisplay(variable.icon);
                if (iconClass) {
                    progressIconHtml = `<i class="${iconClass}" style="margin-right: 6px;"></i>`;
                }
            }
            
            let progressTextParts = [];
            
            if (variable.showIcon && progressIconHtml) {
                progressTextParts.push(progressIconHtml);
            }
            
            if (variable.showLabel && variable.label) {
                progressTextParts.push(variable.label + ':');
            }
            
            if (variable.showValue) {
                progressTextParts.push(variable.formattedValue);
            }
            
            // Falls nichts konfiguriert ist, zeige Wert als Fallback
            if (!variable.showIcon && !variable.showLabel && !variable.showValue) {
                progressTextParts.push(variable.formattedValue);
            }
            
            const progressText = progressTextParts.join(' ');
            
            // Aktualisiere den Haupt-Text
            const mainText = progressTextContainer.querySelector('.progress-main-text');
            if (mainText) {
                mainText.innerHTML = progressText;
                debugLog('Updated progress main text to:', progressText);
            }
            
            // Aktualisiere zweite Variable falls vorhanden
            if (variable.secondVariable) {
                const secondVariableSpan = progressTextContainer.querySelector('.progress-second-variable');
                if (secondVariableSpan) {
                    let secondVariableParts = [];
                    
                    // Icon für zweite Variable
                    if (variable.secondVariable.showIcon && variable.secondVariable.icon && variable.secondVariable.icon !== 'Transparent') {
                        const secondIconClass = prepareIconForDisplay(variable.secondVariable.icon);
                        if (secondIconClass) {
                            secondVariableParts.push(`<i class="${secondIconClass}" style="margin-right: 4px;"></i>`);
                        }
                    }
                    
                    // Label für zweite Variable
                    if (variable.secondVariable.showLabel && variable.secondVariable.label) {
                        secondVariableParts.push(variable.secondVariable.label + ':');
                    }
                    
                    // Wert für zweite Variable
                    if (variable.secondVariable.showValue) {
                        secondVariableParts.push(variable.secondVariable.formattedValue);
                    }
                    
                    // Falls nichts konfiguriert ist, zeige Wert als Fallback
                    if (!variable.secondVariable.showIcon && !variable.secondVariable.showLabel && !variable.secondVariable.showValue) {
                        secondVariableParts.push(variable.secondVariable.formattedValue);
                    }
                    
                    if (secondVariableParts.length > 0) {
                        secondVariableSpan.innerHTML = secondVariableParts.join(' ');
                        debugLog('Updated progress second variable text to:', secondVariableParts.join(' '));
                    }
                }
            }
        }
        
        // Hilfsfunktion für Text-Variable-Update
        function updateTextVariableDisplay(targetVariableId, variable) {
            debugLog('Updating text variable for variable:', variable.id);
            
            const container = document.getElementById('variables-container');
            if (!container) return;
            
            // Suche nach variable-label und variable-value Elementen
            const variableItems = container.querySelectorAll('.variable-item');
            
            variableItems.forEach(item => {
                // Prüfe ob dieses Item die gesuchte Variable enthält
                const labelSpans = item.querySelectorAll('.variable-label');
                const valueSpans = item.querySelectorAll('.variable-value');
                
                // Suche nach dem Label-Text der Variable
                let found = false;
                labelSpans.forEach(labelSpan => {
                    if (labelSpan.textContent.includes(variable.label)) {
                        found = true;
                    }
                });
                
                if (found) {
                    // Aktualisiere die Value-Spans in diesem Item
                    valueSpans.forEach(valueSpan => {
                        if (valueSpan.classList.contains('variable-text')) {
                            valueSpan.textContent = variable.formattedValue;
                            debugLog('Updated text value for variable:', variable.id, 'to:', variable.formattedValue);
                        }
                    });
                }
            });
        }

        function renderStatus(data) {
            debugLog('renderStatus called with data:', data);
            const statusContainer = document.getElementById('status-container');
            const root = document.documentElement;
            
            // Zeige Status-Container nur wenn Status vorhanden ist
            if (data.status) {
                debugLog('Rendering status:', data.status);
                statusContainer.style.display = 'block';
                // Bestimme Status-Farbe: verwende --content-color wenn transparent, ansonsten konfigurierte Farbe
                const statusColor = data.isStatusColorTransparent ? 'var(--content-color)' : (data.statusColor || 'var(--content-color)');
                statusContainer.style.setProperty('--status-color', statusColor);
                statusContainer.style.fontSize = (data.statusFontSize || 12) + 'px';
                
                let statusContent = '';
                
                // Status-Inhalt basierend auf Konfiguration zusammenstellen (wie bei Textvariablen)
                let statusParts = [];
                
                // Icon für Status-Bereich (wenn konfiguriert)
                if (data.statusShowIcon && data.statusIcon && data.statusIcon !== 'Transparent') {
                    const iconClass = prepareIconForDisplay(data.statusIcon);
                    if (iconClass) {
                        statusParts.push(`<i class="${iconClass}" style="color: var(--status-color); margin-right: 4px;"></i>`);
                        debugLog('Status icon rendered:', data.statusIcon, '→', iconClass);
                    }
                }
                
                // Label für Status-Bereich (wenn konfiguriert)
                if (data.statusShowLabel) {
                    const label = data.statusLabel || 'Status'; // Fallback zu "Status" wenn kein Custom Label
                    statusParts.push(`<span class="status-label" style="color: var(--status-color);">${label}:</span>`);
                }
                
                // Wert für Status-Bereich (wenn konfiguriert)
                if (data.statusShowValue) {
                    statusParts.push(`<span class="status-value" style="color: var(--status-color);">${data.status}</span>`);
                }
                
                // Fallback: Falls nichts konfiguriert ist, zeige Wert
                if (!data.statusShowIcon && !data.statusShowLabel && !data.statusShowValue) {
                    statusParts.push(`<span class="status-value" style="color: var(--status-color);">${data.status}</span>`);
                }
                
                statusContent = statusParts.join(' ');
                statusContainer.innerHTML = statusContent;
            } else {
                statusContainer.style.display = 'none';
            }
            
            // Gerätebild wird separat im div1 Container angezeigt - IMMER prüfen, auch ohne Status
            if (data.statusBildauswahl) {
                let imageUrl = null;
                
                // FRONTEND DEBUG: Zeige empfangene Daten und verfügbare Assets
                debugLog('FRONTEND DEBUG: statusBildauswahl received:', data.statusBildauswahl);
                debugLog('FRONTEND DEBUG: Available window.assets:', Object.keys(window.assets || {}));
                
                // DOM-Elemente ZUERST definieren, bevor sie verwendet werden
                const deviceImgContainer = document.getElementById('div1');
                const deviceImg = document.getElementById('image');
                
                if (data.statusBildauswahl === 'none') {
                    // Kein Bild anzeigen
                    debugLog('No image selected (none option)');
                    if (deviceImgContainer) {
                        deviceImgContainer.classList.add('hidden');
                        deviceImgContainer.classList.remove('div1');
                    }
                    // Früh return, da kein Bild gesetzt werden soll
                    return;
                } else if (data.statusBildauswahl.startsWith('img_custom_')) {
                    // Custom Image über Asset-System verwenden
                    imageUrl = window.assets[data.statusBildauswahl];
                    debugLog('Using custom image asset:', data.statusBildauswahl);
                } else {
                    // Vorkonfigurierte Bilder verwenden (wm_an, wm_aus, dryer_on, dryer_off, etc.)
                    imageUrl = window.assets[`img_${data.statusBildauswahl}`];
                }
                
                if (imageUrl && deviceImg && deviceImgContainer) {
                    deviceImg.src = imageUrl;
                    deviceImgContainer.classList.remove('hidden');
                    deviceImgContainer.classList.add('div1');
                    debugLog('Device image added:', imageUrl);
                } else {
                    debugLog('No image URL found for:', data.statusBildauswahl);
                    if (deviceImgContainer) {
                        deviceImgContainer.classList.add('hidden');
                        deviceImgContainer.classList.remove('div1');
                    }
                }
            }
        }

        function renderVariables(variables) {
            debugLog('renderVariables called with ' + (variables ? variables.length : 0) + ' variables');
            console.log('DIRECT DEBUG: renderVariables called with variables:', variables);
            const container = document.getElementById('variables-container');
            if (!container) return;
            
            // Cache die Variablen-Daten für spätere Re-Rendering
            window.cachedVariables = variables;
            
            // Erstelle Mapping zwischen var_X und Variable-ID
            window.varKeyToIdMapping = {};
            window.variableDataCache = {};
            
            debugLog('renderVariables called with:', variables);
            
            // PHASE 1: Berechne maximale Gruppenname-Breite für Alignment
            let maxGroupNameWidth = 0;
            if (window.groupNames) {
                const tempDiv = document.createElement('div');
                tempDiv.style.position = 'absolute';
                tempDiv.style.visibility = 'hidden';
                tempDiv.style.whiteSpace = 'nowrap';
                tempDiv.style.fontWeight = 'bold';
                document.body.appendChild(tempDiv);
                
                // Gruppiere Variablen und finde alle sichtbaren Gruppennamen
                const groupedVariables = variables.reduce((acc, variable) => {
                    if (variable.group && variable.group !== 'keine Gruppe') {
                        if (!acc[variable.group]) acc[variable.group] = [];
                        acc[variable.group].push(variable);
                    }
                    return acc;
                }, {});
                
                // Berechne Breite für jeden sichtbaren Gruppennamen
                Object.keys(groupedVariables).forEach(groupKey => {
                    const groupVariables = groupedVariables[groupKey];
                    const shouldShowGroupName = groupVariables.some(v => v.showGroupName === true);
                    
                    if (shouldShowGroupName) {
                        // Bestimme Anzeigenamen
                        let displayGroupName = groupKey;
                        debugLog('Group name mapping - groupKey: "' + groupKey + '"');
                        debugLog('Group name mapping - window.groupNames available: ' + !!window.groupNames);
                        if (window.groupNames) {
                            debugLog('Group name mapping - available groupNames:', window.groupNames);
                        }
                        const groupMatch = groupKey.match(/Gruppe (\d+)/);
                        debugLog('Group name mapping - groupMatch result:', groupMatch);
                        if (groupMatch && window.groupNames) {
                            const groupNumber = parseInt(groupMatch[1]);
                            debugLog('Group name mapping - groupNumber: ' + groupNumber);
                            debugLog('Group name mapping - looking up: window.groupNames[' + groupNumber + ']');
                            displayGroupName = window.groupNames[groupNumber] || groupKey;
                            debugLog('Group name mapping - final displayGroupName: "' + displayGroupName + '"');
                        } else {
                            debugLog('Group name mapping - no match or no groupNames, using original: "' + displayGroupName + '"');
                        }
                        
                        // Verwende die gleiche Schriftgröße wie die erste Variable
                        const firstVariableFontSize = groupVariables[0]?.fontSize || 14;
                        tempDiv.style.fontSize = firstVariableFontSize + 'px';
                        tempDiv.textContent = displayGroupName + ':';
                        
                        const width = tempDiv.offsetWidth;
                        maxGroupNameWidth = Math.max(maxGroupNameWidth, width);
                        
                        debugLog('Group name "' + displayGroupName + '" width: ' + width + 'px');
                    }
                });
                
                document.body.removeChild(tempDiv);
                debugLog('Maximum group name width for alignment: ' + maxGroupNameWidth + 'px');
            }
            
            // Track welche Gruppen bereits gerendert wurden
            const renderedGroups = new Set();
            let content = '';
            
            // Gehe durch Variablen in ORIGINALER REIHENFOLGE
            variables.forEach((variable, index) => {
                // Erstelle Mapping (var_0, var_1, var_2, etc.)
                const varKey = 'var_' + index;
                window.varKeyToIdMapping[varKey] = variable.id;
                window.variableDataCache[variable.id] = variable;
                debugLog('Mapping created: ' + varKey + ' → ' + variable.id, 'renderVariables');
                debugLog('Processing variable: ' + JSON.stringify(variable), 'renderVariables');
                debugLog('  - displayType: ' + variable.displayType, 'renderVariables');
                debugLog('  - group: ' + variable.group, 'renderVariables');
                
                // Prüfe ob Variable gruppiert ist - ABER: Progress-Balken werden nie gruppiert
                if (variable.group && variable.group !== 'keine Gruppe' && variable.group.trim() !== '' && variable.displayType !== 'progress') {
                    // Nur rendern wenn Gruppe noch nicht gerendert wurde
                    if (!renderedGroups.has(variable.group)) {
                        renderedGroups.add(variable.group);
                        
                        // Sammle alle Variablen dieser Gruppe - OHNE Progress-Balken
                        const groupVariables = variables.filter(v => 
                            v.group === variable.group && v.group !== 'keine Gruppe' && v.group.trim() !== '' && v.displayType !== 'progress'
                        );
                        
                        debugLog('Rendering group: ' + variable.group + ' with ' + groupVariables.length + ' variables', 'renderVariables');
                        
                        // Prüfe ob eine Variable in der Gruppe showBorderLine aktiviert hat
                        const groupHasBorderLine = groupVariables.some(v => v.showBorderLine && v.displayType === 'text');
                        const groupCssClasses = groupHasBorderLine ? 'variable-group with-border-line' : 'variable-group';
                        
                        // Prüfe ob eine Variable in der Gruppe ShowGroupName aktiviert hat
                        const shouldShowGroupName = groupVariables.some(v => v.showGroupName === true);
                        
                        // Debug: Zeige showGroupName Status für alle Variablen in der Gruppe
                        debugLog('Group "' + variable.group + '" showGroupName status:');
                        groupVariables.forEach(v => {
                            debugLog('  Variable ' + v.id + ': showGroupName = ' + v.showGroupName);
                        });
                        debugLog('shouldShowGroupName result: ' + shouldShowGroupName);
                        debugLog('window.groupNames available: ' + (window.groupNames ? 'yes' : 'no'));
                        if (window.groupNames) {
                            debugLog('Available group names:', window.groupNames);
                        }
                        
                        // Bestimme den Gruppennamen basierend auf der Gruppenbezeichnung
                        // WICHTIG: Mapping erfolgt immer wenn window.groupNames verfügbar ist,
                        // shouldShowGroupName kontrolliert nur die Anzeige!
                        let displayGroupName = variable.group;
                        if (window.groupNames) {
                            // Extrahiere Gruppennummer aus "Gruppe X" Format
                            const groupMatch = variable.group.match(/Gruppe (\d+)/);
                            if (groupMatch) {
                                const groupNumber = parseInt(groupMatch[1]);
                                displayGroupName = window.groupNames[groupNumber] || variable.group;
                                debugLog('Group mapping: Gruppe ' + groupNumber + ' -> "' + displayGroupName + '" (showGroupName: ' + shouldShowGroupName + ')');
                            } else {
                                debugLog('No group number found in: "' + variable.group + '"');
                            }
                        } else {
                            debugLog('window.groupNames not available, using default: "' + displayGroupName + '"');
                        }
                        
                        content += `
                            <div class="${groupCssClasses}" style="margin-bottom: var(--element-spacing, 8px); margin-top: var(--element-spacing, 8px); display: flex; align-items: flex-start; gap: 16px;">
                        `;
                        
                        // Füge Gruppennamen links hinzu wenn gewünscht
                        if (shouldShowGroupName) {
                            // Verwende die gleiche Schriftgröße wie die erste Variable der Gruppe
                            const firstVariableFontSize = groupVariables[0]?.fontSize || 14;
                            
                            // Verwende feste Breite für einheitliches Alignment aller Gruppen
                            const groupNameWidth = maxGroupNameWidth > 0 ? maxGroupNameWidth + 'px' : 'auto';
                            
                            content += `
                                <div class="group-name-label" style="font-weight: bold; color: var(--content-color); font-size: ${firstVariableFontSize}px; white-space: nowrap; align-self: center; margin-right: 8px; width: ${groupNameWidth}; display: inline-block; text-align: left;">
                                    ${displayGroupName}:
                                </div>
                            `;
                            
                            debugLog('Group name "' + displayGroupName + '" using font size: ' + firstVariableFontSize + 'px, aligned width: ' + groupNameWidth);
                        }
                        
                        content += `
                                <div class="variable-group-items" style="display: flex; flex-wrap: wrap; gap: 16px; align-items: flex-start; flex: 1;">
                        `;
                        
                        groupVariables.forEach(groupVar => {
                            content += `<div class="variable-group-item">`;
                            content += renderSingleVariable(groupVar, true); // true = isGrouped
                            content += `</div>`;
                        });
                        
                        content += `
                                </div>
                            </div>
                        `;
                    }
                    // Andernfalls überspringen (Gruppe bereits gerendert)
                } else {
                    // Ungrouped variable - sofort rendern
                    content += renderSingleVariable(variable);
                }
            });
            
            debugLog('Rendered groups: ' + Array.from(renderedGroups).join(','));
            
            // Rufe updateImageVisibility() nach dem initialen Rendering auf
            // um sicherzustellen, dass die Bildanzeige korrekt gesetzt wird
            updateImageVisibility();
            
            container.innerHTML = content;
        }
        
        // Hilfsfunktion zum Rendern einer einzelnen Variable
        function renderSingleVariable(variable, isGrouped = false) {
            let content = '';
            
            // Spezialbehandlung für Progress-Balken: Niemals inline, auch nicht in Gruppen
            const isProgressBar = variable.displayType === 'progress';
            
            // Wrapper-Stil je nach Kontext (grouped oder ungrouped) - Progress-Balken immer full-width
            const wrapperStyle = (isGrouped && !isProgressBar) ? 
                `display: inline-flex; align-items: center; margin: 0; white-space: nowrap; font-size: ${variable.fontSize}px; color: ${getTextColor(variable)};` : 
                `font-size: ${variable.fontSize}px; color: ${getTextColor(variable)};`;
                
            // CSS-Klassen für Variable zusammenstellen
            let cssClasses = 'variable-item';
            if (variable.displayType === 'text') {
                cssClasses += ' text-variable';
            }
            // Füge border-line Klasse hinzu wenn konfiguriert UND NICHT gruppiert
            // Bei gruppierten Variablen zeigt nur die Gruppe die Linie, nicht die einzelnen Variablen
            if (variable.showBorderLine && variable.displayType === 'text' && !isGrouped) {
                cssClasses += ' with-border-line';
            }
                
            content += `<div class="${cssClasses}" style="${wrapperStyle}">`;

                // Wert je nach Darstellungstyp hinzufügen
                if (variable.displayType === 'progress') {
                    // Fortschrittsbalken - nutze zentrale Konfiguration
                    // Prüfe Progressbar Active Status - wenn inaktiv, überschreibe mit 0-Werten
                    let rawValue, progressValue, displayValue;
                    
                    if (variable.progressbarActive === false) {
                        // Progressbar inaktiv - zeige 0-Werte und verhindere Updates
                        rawValue = 0;
                        progressValue = 0;
                        
                        // Extrahiere Suffix aus ursprünglichem formatiertem Wert
                        const originalFormatted = variable.formattedValue || '';
                        const suffixMatch = originalFormatted.match(/[^0-9.,\-\s]+/);
                        const suffix = suffixMatch ? suffixMatch[0] : '';
                        
                        displayValue = '0 ' + suffix;
                        debugLog('Progress bar disabled for variable ' + variable.id + ' - showing zero values with suffix: "' + suffix + '"');
                    } else {
                        // Progressbar aktiv - normale Berechnung
                        rawValue = parseFloat(variable.rawValue) || 0;
                        const minValue = parseFloat(variable.progressMin) || 0;
                        const maxValue = parseFloat(variable.progressMax) || 100;
                        
                        // Stelle sicher, dass maxValue > minValue
                        const range = maxValue - minValue;
                        progressValue = 0;
                        
                        if (range > 0) {
                            progressValue = Math.max(0, Math.min(100, ((rawValue - minValue) / range) * 100));
                        }
                        displayValue = variable.formattedValue;
                    }
                    
                    // Berechne Prozentsatz basierend auf Min/Max-Werten
                    const progressPercent = progressValue.toFixed(1) + '%';
                    
                    debugLog('Progress bar calculation for variable', variable.id + ':', {
                        rawValue: rawValue,
                        progressPercent: progressPercent,
                        progressbarActive: variable.progressbarActive
                    });
                    
                    // Progress-Bar Inhalt basierend auf Konfiguration
                    let progressIconHtml = '';
                    if (variable.showIcon && variable.icon && variable.icon !== 'Transparent') {
                        const iconClass = prepareIconForDisplay(variable.icon);
                        if (iconClass) {
                            progressIconHtml = `<i class="${iconClass} variable-icon" style="color: ${getTextColor(variable)};"></i>`;
                        }
                    }
                    
                    let progressTextParts = [];
                    
                    if (variable.showIcon && progressIconHtml) {
                        progressTextParts.push(progressIconHtml);
                    }
                    
                    if (variable.showLabel && variable.label) {
                        progressTextParts.push(`<span style="color: ${getTextColor(variable)}; font-weight: 700;">${variable.label}:&nbsp;</span>`);
                    }
                    
                    if (variable.showValue) {
                        progressTextParts.push(`<span style="color: ${getTextColor(variable)};">${displayValue}</span>`);
                    }
                    
                    // Falls nichts konfiguriert ist, zeige Wert als Fallback
                    if (!variable.showIcon && !variable.showLabel && !variable.showValue) {
                        progressTextParts.push(`<span style="color: ${getTextColor(variable)};">${displayValue}</span>`);
                    }
                    
                    const progressText = progressTextParts.join('');
                    
                    // Zweite Variable für rechte Seite vorbereiten
                    let secondVariableText = '';
                    if (variable.secondVariable) {
                        let secondVariableParts = [];
                        
                        // Icon für zweite Variable
                        if (variable.secondVariable.showIcon && variable.secondVariable.icon && variable.secondVariable.icon !== 'Transparent') {
                            const secondIconClass = prepareIconForDisplay(variable.secondVariable.icon);
                            if (secondIconClass) {
                                secondVariableParts.push(`<i class="${secondIconClass} variable-icon" style="color: ${getTextColor(variable)};"></i>`);
                            }
                        }
                        
                        // Label für zweite Variable
                        if (variable.secondVariable.showLabel && variable.secondVariable.label) {
                            secondVariableParts.push(`<span style="color: ${getTextColor(variable)}; font-weight: 700;">${variable.secondVariable.label}:&nbsp;</span>`);
                        }
                        
                        // Wert für zweite Variable
                        if (variable.secondVariable.showValue) {
                            let secondVariableDisplayValue;
                            if (variable.progressbarActive === false) {
                                // Extrahiere Suffix aus zweiter Variable
                                const secondOriginalFormatted = variable.secondVariable.formattedValue || '';
                                const secondSuffixMatch = secondOriginalFormatted.match(/[^0-9.,\-\s]+/);
                                const secondSuffix = secondSuffixMatch ? secondSuffixMatch[0] : '';
                                secondVariableDisplayValue = '0 ' + secondSuffix;
                            } else {
                                secondVariableDisplayValue = variable.secondVariable.formattedValue;
                            }
                            secondVariableParts.push(`<span style="color: ${getTextColor(variable)};">${secondVariableDisplayValue}</span>`);
                        }
                        
                        // Falls nichts konfiguriert ist, zeige Wert als Fallback
                        if (!variable.secondVariable.showIcon && !variable.secondVariable.showLabel && !variable.secondVariable.showValue) {
                            secondVariableParts.push(`<span style="color: ${getTextColor(variable)};">${variable.secondVariable.formattedValue}</span>`);
                        }
                        
                        if (secondVariableParts.length > 0) {
                            secondVariableText = `<span class="progress-second-variable">${secondVariableParts.join(' ')}</span>`;
                            debugLog('Second variable for progress bar:', variable.secondVariable.id, '→', secondVariableParts.join(' '));
                        }
                    }
                    
                  
                    // Berechne individuelles Padding basierend auf Variable-Textgröße
                    const individualPadding = Math.max(4, Math.round(variable.fontSize / 2)); // Minimum 4px
                    
                    content += `
                        <div class="variable-progress">
                            <div class="progress-container" data-variable-id="${variable.id}" style="--progress-color1: ${variable.progressColor1}; --progress-color2: ${variable.progressColor2}; --progress-bar-text-padding: ${individualPadding}px;">
                                <div class="progress-bar" style="width: ${progressValue}%;"></div>
                                <div class="progress-text">
                                    <span class="progress-main-text">${progressText}</span>
                                    ${secondVariableText}
                                </div>
                            </div>
                        </div>
                    `;
                } else if (variable.displayType === 'button') {
                    // Button für Bool-Variablen (VARIABLETYPE_BOOLEAN = 0) und Integer-Variablen (VARIABLETYPE_INTEGER = 1)
                    if (variable.variableType === 0) {
                        // Boolean-Variable: Einzelner Button
                        console.log('=== BOOLEAN BUTTON DEBUG START ===');
                        console.log('Variable ID:', variable.id, 'Variable Type:', variable.variableType);
                        console.log('Raw Value:', variable.rawValue, 'Type:', typeof variable.rawValue);
                        
                        // Erweiterte Bool-Wert-Erkennung
                        const isActive = variable.rawValue === true || variable.rawValue === 1 || variable.rawValue === '1' || variable.rawValue === 'true';
                        // Verwende den tatsächlichen Boolean-Wert für Association-Matching (nicht Integer-Konvertierung!)
                        const currentBoolValue = variable.rawValue; // Direkt verwenden, da Associations auch Boolean-Werte haben
                        
                        console.log('isActive:', isActive, 'currentBoolValue for matching:', currentBoolValue, 'type:', typeof currentBoolValue);
                        
                        // Bool Buttons verwenden ausschließlich boolButtonColor (initial rendering)
                        let buttonColor = 'var(--accent-color)';
                        let associationIcon = null;
                        let associationName = null;
                        
                        // Verwende ausschließlich boolButtonColor für Bool Buttons (initial rendering)
                        if (variable.isBoolButtonColorTransparent) {
                            buttonColor = 'var(--accent-color)';
                        } else {
                            buttonColor = variable.boolButtonColor || 'var(--accent-color)';
                        }
                        
                        debugLog('Bool Button initial rendering using exclusive boolButtonColor:', {
                            boolButtonColor: variable.boolButtonColor,
                            isTransparent: variable.isBoolButtonColorTransparent,
                            finalColor: buttonColor
                        });
                        
                        // Association-Icon und Name für Bool Buttons (nur für Icon/Name, nicht für Farbe)
                        const associations = variable.variableAssociations;
                        if (associations && Array.isArray(associations)) {
                            const currentAssociation = associations.find(assoc => assoc.value === currentBoolValue);
                            if (currentAssociation) {
                                associationIcon = currentAssociation.icon;
                                associationName = currentAssociation.name;
                                debugLog('Boolean button initial rendering using association icon/name only:', {
                                    icon: associationIcon,
                                    name: associationName
                                });
                            }
                        }
                        
                        const opacity = isActive ? '1' : '0.7';
                        const buttonWidth = variable.buttonWidth || 120;
                        
                        let buttonText = '';
                        let iconHtml = '';
                        
                        // Icon-Verarbeitung für Button - Verwende Association-Icon falls vorhanden
                        let finalIcon = associationIcon || variable.icon; // Association-Icon hat Priorität
                        if (variable.showIcon && finalIcon && finalIcon !== 'Transparent') {
                            const iconClass = prepareIconForDisplay(finalIcon);
                            if (iconClass) {
                                iconHtml = `<i class="${iconClass}" style="margin-right: 6px;"></i>`;
                            }
                        }
                        
                        // Button-Inhalt basierend auf allgemeiner Konfiguration zusammenstellen
                        let textParts = [];
                        
                        if (variable.showIcon && iconHtml) {
                            textParts.push(iconHtml);
                        }
                        
                        if (variable.showLabel) {
                            // Verwende Variablenname als Label (höchste Priorität), dann Association-Name als Fallback
                            const displayLabel = variable.label || associationName || (isActive ? 'ON' : 'OFF');
                            if (variable.showValue) {
                                // Doppelpunkt nur wenn auch Value angezeigt wird - Label fett
                                textParts.push(`<span style="font-weight: 700;">${displayLabel}:&nbsp;</span>`);
                            } else {
                                // Kein Doppelpunkt wenn nur Label - Label fett
                                textParts.push(`<span style="font-weight: 700;">${displayLabel}</span>`);
                            }
                        }
                        
                        if (variable.showValue) {
                            textParts.push(`<span style="font-weight: normal;">${variable.formattedValue}</span>`);
                        }
                        
                        // Falls keine Checkbox aktiviert ist, zeige Label als Fallback (ohne Doppelpunkt) - fett
                        if (!variable.showIcon && !variable.showLabel && !variable.showValue) {
                            textParts.push(`<span style="font-weight: 700;">${variable.label || (isActive ? 'ON' : 'OFF')}</span>`);
                        }
                        
                        buttonText = textParts.join(' ');
                        
                        // Spezielle Behandlung für nur Icon (ohne Abstand)
                        if (variable.showIcon && !variable.showLabel && !variable.showValue && iconHtml) {
                            buttonText = iconHtml.replace('margin-right: 6px;', '');
                        }
                        
                        // Debug-Ausgaben
                        debugLog('Button Debug for variable: ' + variable.id, 'renderSingleVariable');
                        debugLog('  - showIcon: ' + variable.showIcon, 'renderSingleVariable');
                        debugLog('  - showLabel: ' + variable.showLabel, 'renderSingleVariable');
                        debugLog('  - showValue: ' + variable.showValue, 'renderSingleVariable');
                        debugLog('  - buttonWidth: ' + buttonWidth, 'renderSingleVariable');
                        debugLog('  - isActive: ' + isActive, 'renderSingleVariable');
                        debugLog('  - buttonColor: ' + buttonColor, 'renderSingleVariable');
                        debugLog('  - opacity: ' + opacity, 'renderSingleVariable');
                        debugLog('  - buttonText: ' + buttonText, 'renderSingleVariable');
                        
                        content += `
                            <div class="variable-button-container">
                                <button class="variable-button" 
                                        onclick="requestAction('${variable.id}', 1); debugLog('Button clicked for variable: ${variable.id}');" 
                                        data-variable-id="${variable.id}"
                                        style="background-color: ${buttonColor} !important; opacity: ${opacity} !important; color: ${getTextColor(variable)} !important; width: ${buttonWidth}px; min-width: ${buttonWidth}px;">
                                    ${buttonText}
                                </button>
                            </div>
                        `;
                        
                        debugLog('  - FINAL: Button rendered with color:', buttonColor, 'opacity:', opacity, 'width:', buttonWidth + 'px');
                    } else if ((variable.variableType === 1 || variable.variableType === 3) && (variable.variableAssociations || variable.integerAssociations)) {
                        // Integer/String-Variable: Multi-Button für jede Association
                        const associations = variable.variableAssociations || variable.integerAssociations;
                        const variableTypeLabel = variable.variableType === 1 ? 'Integer' : 'String';
                        debugLog('Rendering multi-buttons for', variableTypeLabel, 'variable:', variable.id, 'with', associations.length, 'associations');
                        
                        // ButtonWidth aus Variablenkonfiguration verwenden (wie bei Boolean-Buttons)
                        const buttonWidth = variable.buttonWidth || 80; // Etwas schmaler für Multi-Buttons
                        debugLog('Multi-button width for variable:', variable.id, '→', buttonWidth + 'px');
                        
                        let buttonsHtml = '';
                        const currentValue = variable.variableType === 1 ? parseInt(variable.rawValue) : variable.rawValue;
                        
                        associations.forEach((association, index) => {
                            const isActive = currentValue === association.value;
                            const buttonColor = association.color || 'var(--accent-color)';
                            const opacity = isActive ? '1' : '0.7';
                            
                            // Button-Gruppierung: Bestimme CSS-Klasse basierend auf Position
                            let positionClass = '';
                            const totalButtons = associations.length;
                            
                            if (totalButtons === 1) {
                                positionClass = 'single-button'; // Nur ein Button: alle Ecken rund
                            } else if (index === 0) {
                                positionClass = 'first-button'; // Erster Button: nur links rund
                            } else if (index === totalButtons - 1) {
                                positionClass = 'last-button'; // Letzter Button: nur rechts rund
                            } else {
                                positionClass = 'middle-button'; // Mittlere Buttons: keine runden Ecken
                            }
                            
                            // Button-Text basierend auf Association-Name
                            let buttonText = association.name || `Wert ${association.value}`;
                            
                            // Icon hinzufügen falls vorhanden
                            if (association.icon && association.icon !== 'Transparent') {
                                const iconClass = prepareIconForDisplay(association.icon);
                                if (iconClass) {
                                    buttonText = `<i class="${iconClass}" style="margin-right: 4px;"></i>${buttonText}`;
                                }
                            }
                            
                            buttonsHtml += `
                                <button class="variable-multi-button ${positionClass} ${isActive ? 'active' : ''}" 
                                        onclick="requestAction('${variable.id}', ${variable.variableType === 1 ? association.value : "'" + association.value + "'"}); debugLog('Multi-button clicked for variable: ${variable.id}, value: ${association.value}');" 
                                        data-variable-id="${variable.id}"
                                        data-association-value="${association.value}"
                                        style="background-color: ${buttonColor} !important; color: ${getTextColor(variable)} !important; opacity: ${opacity}; width: ${buttonWidth}px; min-width: ${buttonWidth}px;">
                                    ${buttonText}
                                </button>`;
                        });
                        
                        content += `
                            <div class="variable-button-container">
                                <div class="variable-multi-button-container">
                                    ${buttonsHtml}
                                </div>
                            </div>
                        `;
                        
                        debugLog('Multi-buttons rendered for variable:', variable.id, 'current value:', currentValue);
                    } else if (variable.variableType === 3 && variable.stringAssociations && variable.stringAssociations.length > 0) {
                        // String-Variable: Multi-Button für jede Association
                        debugLog('Rendering multi-buttons for String variable:', variable.id, 'with', variable.stringAssociations.length, 'associations');
                        
                        // ButtonWidth aus Variablenkonfiguration verwenden (wie bei Boolean-Buttons)
                        const buttonWidth = variable.buttonWidth || 80; // Etwas schmaler für Multi-Buttons
                        debugLog('Multi-button width for string variable:', variable.id, '→', buttonWidth + 'px');
                        
                        let buttonsHtml = '';
                        const currentValue = String(variable.rawValue); // String-Wert als String behandeln
                        
                        variable.stringAssociations.forEach((association, index) => {
                            const isActive = currentValue === String(association.value);
                            const buttonColor = association.color || 'var(--accent-color)';
                            const opacity = isActive ? '1' : '0.7';
                            
                            // Button-Gruppierung: Bestimme CSS-Klasse basierend auf Position
                            let positionClass = '';
                            const totalButtons = variable.stringAssociations.length;
                            
                            if (totalButtons === 1) {
                                positionClass = 'single-button'; // Nur ein Button: alle Ecken rund
                            } else if (index === 0) {
                                positionClass = 'first-button'; // Erster Button: nur links rund
                            } else if (index === totalButtons - 1) {
                                positionClass = 'last-button'; // Letzter Button: nur rechts rund
                            } else {
                                positionClass = 'middle-button'; // Mittlere Buttons: keine runden Ecken
                            }
                            
                            // Button-Text basierend auf Association-Name
                            let buttonText = association.name || String(association.value);
                            
                            // Icon hinzufügen falls vorhanden
                            if (association.icon && association.icon !== 'Transparent') {
                                const iconClass = prepareIconForDisplay(association.icon);
                                if (iconClass) {
                                    buttonText = `<i class="${iconClass}" style="margin-right: 4px;"></i>${buttonText}`;
                                }
                            }
                            
                            buttonsHtml += `
                                <button class="variable-multi-button ${positionClass} ${isActive ? 'active' : ''}" 
                                        onclick="requestAction('${variable.id}', '${association.value}'); debugLog('String multi-button clicked for variable: ${variable.id}, value: ${association.value}');" 
                                        data-variable-id="${variable.id}"
                                        data-association-value="${association.value}"
                                        style="background-color: ${buttonColor} !important; color: ${getTextColor(variable)} !important; opacity: ${opacity}; width: ${buttonWidth}px; min-width: ${buttonWidth}px;">
                                    ${buttonText}
                                </button>`;
                        });
                        
                        content += `
                            <div class="variable-button-container">
                                <div class="variable-multi-button-container">
                                    ${buttonsHtml}
                                </div>
                            </div>
                        `;
                        
                        debugLog('String multi-buttons rendered for variable:', variable.id, 'current value:', currentValue);
                    } else {
                        // Fallback für Nicht-Bool/Integer/String-Variablen oder Variablen ohne Associations: Zeige als Text
                        if (variable.variableType === 1) {
                            console.warn('Integer variable', variable.id, 'has no associations for button display. Showing as text.');
                        } else if (variable.variableType === 3) {
                            console.warn('String variable', variable.id, 'has no associations for button display. Showing as text.');
                        } else {
                            console.warn('Button display type only supported for boolean, integer, and string variables. Variable', variable.id, 'is type', variable.variableType);
                        }
                        
                        let textParts = [];
                        
                        if (variable.showLabel && variable.label) {
                            textParts.push(`<span class="variable-label" style="color: ${getTextColor(variable)};">${variable.label}:&nbsp;</span>`);
                        }
                        
                        if (variable.showValue) {
                            textParts.push(`<span class="variable-value variable-text">${variable.formattedValue}</span>`);
                        }
                        
                        // Falls nichts konfiguriert ist, zeige Wert als Fallback
                        if (!variable.showLabel && !variable.showValue) {
                            textParts.push(`<span class="variable-value variable-text">${variable.formattedValue}</span>`);
                        }
                        
                        content += `<div class="variable-item">
                            ${textParts.join(' ')}
                        </div>`;
                    }
                } else {
                    // Bei Textdarstellung: Label und Wert basierend auf Konfiguration
                    let textParts = [];
                    
                    // Icon für Text-Variablen
                    if (variable.showIcon && variable.icon && variable.icon !== 'Transparent') {
                        const iconClass = prepareIconForDisplay(variable.icon);
                        if (iconClass) {
                            textParts.push(`<i class="${iconClass} variable-icon" style="color: var(--accent-color);"></i>`);
                            debugLog(`Text variable icon rendered: ${variable.label}: ${variable.icon} → ${iconClass}`);
                        }
                    }
                    
                    if (variable.showLabel && variable.label) {
                        textParts.push(`<span class="variable-label" style="color: ${getTextColor(variable)};">${variable.label}:&nbsp;</span>`);
                    }
                    
                    if (variable.showValue) {
                        textParts.push(`<span class="variable-value variable-text">${variable.formattedValue}</span>`);
                    }
                    
                    // Falls nichts konfiguriert ist, zeige Wert als Fallback
                    if (!variable.showIcon && !variable.showLabel && !variable.showValue) {
                        textParts.push(`<span class="variable-value variable-text">${variable.formattedValue}</span>`);
                    }
                    
                    content += textParts.join('');
                }

                content += `</div>`; // Schließe variable-item div
                
            return content;
        }

    </script>


</head>

<body>
    <div class="main_container">
        <div id="div1" class="hidden">
            <img id="image" alt="Device Image">
        </div>
        <div class="div2" id="div2">
            <div id="status-container" class="status-container" style="display: none;">
                <!-- Status wird hier angezeigt -->
            </div>
            <div id="variables-container">
                <!-- Dynamische Variablen werden hier eingefügt -->
            </div>
        </div>
    </div>
</body>

</html>
