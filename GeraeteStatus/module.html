<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <script src="/icons.js" crossorigin="anonymous"></script>

    <style>
        /* Grundlegende Stildefinitionen für die neue dynamische Variablenliste */

        :root {
            --bildbreite: 40%;
            --bildtransparenz: 1;
            --hintergrundfarbe: rgba(255, 255, 255, 0.95);
            --element-spacing: 8px; /* Einheitlicher vertikaler Abstand zwischen allen Elementen */
        }

        html {
            background-color: var(--hintergrundfarbe);
            overflow: hidden;
        }

        body:before {
            content: '';
            display: block;
            position: fixed;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            background-repeat: no-repeat;
            background-size: cover;
            opacity: var(--bildtransparenz);
            background: var(--background-image, none) center / cover no-repeat;
        }

        body {
            font-family: Arial, sans-serif;
        }

        .hidden {
            display: none;
        }

        .visible {
            display: block;
        }

        .main_container {
            width: 100%;
            max-width: 100%;
            display: flex;
            flex-wrap: nowrap;
            justify-content: center;
            box-sizing: border-box;
        }

        .div1 {
            box-sizing: border-box;
            border-right: 1px solid color-mix(in srgb, var(--accent-color) 50%, transparent);
            padding-right: 10px;
        }

        .div1 img {
            width: var(--bildbreite);
        }
        
        /* CRITICAL FIX: Verhindere div1 Kollaps durch robuste CSS-Lösung */
        .main_container .div1 {
            /* Mindestbreite für div1 auch ohne Bild */
            min-width: 50px !important;
        }
        
        /* Transparenter Platzhalter NUR für leere Bilder - iOS FIX */
        .main_container .div1 img:not([src]), 
        .main_container .div1 img[src=""] {
            /* 1x1 transparentes PNG als Hintergrundbild */
            background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAABBJREFUeNpi+P//PwNAgAEACPwC/tuiTRYAAAAASUVORK5CYII=') !important;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            /* Mindestgröße mit höherer Priorität */
            min-width: 40px !important;
            min-height: 40px !important;
            width: var(--bildbreite) !important;
            display: block !important;
            /* Fallback für leere src */
            content: '' !important;
            color: transparent !important;
        }
        
        /* Normale img-Elemente: Nur Basis-Styling ohne background-image Override */
        .main_container .div1 img {
            width: var(--bildbreite) !important;
            min-width: var(--bildbreite) !important;
            max-width: var(--bildbreite) !important;
            height: auto !important; /* Preserve aspect ratio */
            object-fit: contain;     /* Keep image inside its box without stretching */
            display: block;
            box-sizing: border-box;
        }

        .div2 {
            flex: 1;
            box-sizing: border-box;
            margin: 0px 0px 0px 0px;
            border-radius: 0px;
        }

        /* Bildposition: Links (Standard) */
        .main_container.image-left {
            flex-direction: row;
            gap: 10px;
        }

        /* Bei links/rechts: Bild in der linken/rechten Spalte oben ausrichten */
        .main_container.image-left .div1,
        .main_container.image-right .div1 {
            display: flex;
            align-items: flex-start; /* oben */
        }

        /* Bildposition: Rechts */
        .main_container.image-right {
            flex-direction: row-reverse;
            gap: 10px;
        }
        
        .main_container.image-right .div1 {
            border-right: none;
            border-left: 1px solid color-mix(in srgb, var(--accent-color) 50%, transparent);
            padding-left: 10px; 
        }

        /* Bildposition: Oben */
        .main_container.image-top {
            flex-direction: column;
            gap: 20px;
        }
        
        .main_container.image-top .div1 {
            width: 100% !important;
            min-width: 100%;
            max-width: 100%;
            border-right: none;
            border-bottom: 1px solid color-mix(in srgb, var(--accent-color) 50%, transparent);
            padding-right: 0;
            padding-bottom: 20px;
            display: flex;
            justify-content: center; /* Standard: Zentriert */
            align-items: center;      /* Verhindert vertikales Strecken von img */
        }
        
        .main_container.image-top .div1 img {
            width: var(--bildbreite);
            max-width: var(--bildbreite);
            height: auto;           /* Preserve aspect ratio */
            object-fit: contain;    /* Avoid stretching when container grows */
            display: block;
        }

        /* Bildposition: Unten */
        .main_container.image-bottom {
            flex-direction: column-reverse;
            gap: 20px;
        }
        
        .main_container.image-bottom .div1 {
            width: 100% !important;
            min-width: 100%;
            max-width: 100%;
            border-right: none;
            border-top: 1px solid color-mix(in srgb, var(--accent-color) 50%, transparent);
            border-bottom: none;
            padding-right: 0;
            padding-top: 20px;
            display: flex;
            justify-content: center; /* Standard: Zentriert */
            align-items: center;      /* Verhindert vertikales Strecken von img */
        }
        
        .main_container.image-bottom .div1 img {
            width: var(--bildbreite);
            max-width: var(--bildbreite);
            height: auto;           /* Preserve aspect ratio */
            object-fit: contain;    /* Avoid stretching when container grows */
            display: block;
        }
        
        .main_container.image-bottom .div2 {
            width: 100%;
        }
        
        /* Trennlinie ausblenden */
        .main_container.hide-border-line .div1 {
            border: none !important;
        }
        
        


        /* Styles für dynamische Variablen */
        .variables-container {
            display: flex;
            flex-direction: column;
            width: 100%;
        }

        .variable-item {
            margin: calc(var(--element-spacing, 8px)) 0;
            display: flex;
            align-items: center; /* Vertikale Zentrierung aller Inhalte */
            justify-content: flex-start; /* Horizontale Ausrichtung */
            width: 100%;
            min-height: 15px; /* Reduzierte Mindesthöhe für kompaktere Darstellung */
        }
        
        /* Für gruppierte Variablen: Standardmäßig nur Inhaltsbreite */
        .variable-group-item {
            flex: 0 0 auto; /* Nur Inhaltsbreite, kein Wachstum oder Schrumpfen */
        }
        
        /* Wachstum des letzten Items wird beim Rendern inline vergeben (letztes NICHT-Bild-Item) */
        
        /* Progress-Balken: Auch in der Mitte können sie wachsen wenn nötig */
        .variable-group-item:has(.progress-variable) {
            flex: 1 1 100px; /* Mindestens 100px, kann wachsen */
        }
        
        /* SPEZIAL: Für group-name-above Layout (flex-direction: column) */
        .variable-group:has(.group-name-above) .variable-group-items {
            width: 100% !important; /* Volle Breite für showAbove Layout */
        }
        
        .variable-group:has(.group-name-above) .variable-group-item:has(.progress-variable) {
            width: 100% !important; /* Progress-Container in showAbove Layout volle Breite */
            flex: none; /* Kein Flex-Wachstum, sondern direkte width: 100% */
        }
        
        .variable-group-item .variable-item {
            width: auto;
            margin-bottom: 0;
            margin-top: 0;
        }
        
        /* Bild-Variablen in Gruppen: Display flex für column layout, wachsen NICHT */
        .variable-group-item:has(.variable-inline-image) {
            display: flex;
            flex: 0 0 auto; /* nur Inhaltsbreite */
            min-width: 0; /* Überlauf durch Inhalte verhindern */
            overflow: hidden; /* Clipping innerhalb des Items */
        }
        /* Wachstum des letzten Items steuern wir inline beim Rendern */
        .variable-group-item:has(.variable-inline-image) .variable-inline-image {
            /* Breite wird durch inline-style gesetzt (imageWidth) bzw. 100% vom Item in Gruppen */
            height: auto !important;
            flex: 0 0 auto !important;
            display: block; /* Entfernt inline-Grafik-Zwischenräume */
            max-width: 100%;
        }
        /* Innerer Wrapper für Bild-Gruppenelemente: Inhalte (Label/Value) unter dem Bild stapeln */
        .variable-group-item:has(.variable-inline-image) .variable-item {
            display: flex;
            flex-direction: column;
            /* align-items wird durch inline-style gesetzt basierend auf alignment */
            width: 100%; /* Fülle Item-Breite des .variable-group-item */
            min-width: 0; /* Inhalte dürfen innerhalb des Items schrumpfen */
        }
        /* Label/Value an Item-Breite binden, Überlauf vermeiden */
        /* text-align wird durch inline-style gesetzt basierend auf alignment */
        .variable-group-item:has(.variable-inline-image) .variable-label,
        .variable-group-item:has(.variable-inline-image) .variable-value {
            max-width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .variable-group-item:has(.variable-inline-image) .variable-value {
            flex-grow: 0;
        }
        
        /* Stretch-Gruppen: variable-item braucht volle Breite */
        .variable-group.stretch-buttons .variable-group-item .variable-item {
            width: 100% !important;
        }
        
        /* AUSNAHME: Progress-Balken brauchen volle Breite, auch in Gruppen */
        .variable-group-item .variable-item .progress-container {
            width: 100%;
        }
        /* Slider in Gruppen: volle Breite und flexibles Wachstum */
        .variable-group-item:has(.slider-container) {
            flex: 1 1 200px;
            min-width: 0;
        }
        .variable-group-item:has(.slider-container) .variable-item {
            width: 100% !important;
            min-width: 0 !important;
        }
        .variable-group-item .variable-item .slider-container {
            width: 100% !important;
        }
        
        /* AUSNAHME: Progress-Bar-Container brauchen volle Breite */
        .variable-group-item .variable-progress {
            width: 100%;
            min-width: 100%;
        }
        
        /* KRITISCH: Progress-Variablen in Gruppen müssen sichtbar sein */
        .variable-group-item .progress-variable {
            display: flex !important;
            width: 100% !important;
            flex-direction: row;
            flex: 1 1 200px; /* Wachsen mit verfügbarem Platz, aber min 200px */
        }
        
        /* SPEZIFISCHER: Progress-Container in gruppierten Variablen braucht volle Container-Breite */
        .variable-group-item .progress-variable .progress-container {
            width: 100% !important;
            min-width: 100% !important;
            flex: none !important;
        }
        
        /* Sicherstelle dass Progress-Container in Gruppen korrekt angezeigt werden */
        .variable-group-item .progress-variable .variable-progress {
            display: flex !important;
            width: 100% !important;
        }
        
        /* Für gruppierte Variablen: Kein min-width bei Labels für kompakte Darstellung */
        .variable-group-item .variable-label {
            min-width: auto;
        }

        .variable-icon {
            margin-right: 5px;
            margin-top: calc(var(--element-spacing, 8px));
            margin-bottom: calc(var(--element-spacing, 8px));
            display: inline-block;
            vertical-align: baseline;
            flex-shrink: 0;
        }

        .variable-label {
            font-weight: bold;
            min-width: 0px;  /* Feste Breite für Labels */
            flex-shrink: 0;
            display: flex;
            align-items: center; /* Vertikale Zentrierung für Labels */
            margin: calc(var(--element-spacing, 8px)) 0; /* Einheitlicher Abstand wie bei variable-text */
        }

        .variable-value {
            flex-grow: 1;
            text-align: left;
            display: flex;
            align-items: center; /* Vertikale Zentrierung für Values */
        }

        img.variable-inline-image {
            margin-top: 5px;
            margin-bottom: 5px;
        }

        /* Fortschrittsbalken-Styles - verwende zentrale Konfiguration */
        .progress-container {
            margin-bottom: var(--element-spacing, 8px); /* Einheitlicher vertikaler Abstand */
            margin-top: var(--element-spacing, 8px); /* Einheitlicher vertikaler Abstand */
            width: 100%;
            background-color: var(--progress-bar-bg-color, rgba(135, 135, 135, 0.3));
            border-radius: var(--progress-bar-border-radius, 10px);
            overflow: hidden;
            position: relative;
        }

        .progress-bar {
            height: 100%;
            border-radius: var(--progress-bar-border-radius, 10px) 0 0 var(--progress-bar-border-radius, 10px);
            transition: width 3s ease-in-out;
            background: linear-gradient(to right, var(--progress-color1), var(--progress-color2));
            /* Prefer OKLCH interpolation where supported for smoother, perceptually uniform gradients */
            background: linear-gradient(to right in oklch, var(--progress-color1), var(--progress-color2));
            min-height: var(--progress-bar-height, 20px);
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 6px;
            width: 100%;
        }
        .slider-track {
            position: relative;
            flex: 1 1 auto;
            height: var(--slider-height, 5px);
            background: var(--progress-bar-bg-color, rgba(135, 135, 135, 0.25));
            border-radius: var(--slider-radius, 9999px);
            overflow: visible; /* allow thumb to protrude so it's fully circular */
            touch-action: none;
            box-shadow: inset 0 0 0 1px color-mix(in srgb, #000 20%, transparent);
        }
        .slider-track::after {
            content: "";
            position: absolute;
            left: 0; top: 0; right: 0; bottom: 0;
            background-image: radial-gradient(circle, var(--slider-dots-color, var(--progress-color1)) var(--slider-dot-radius, 1px), transparent var(--slider-dot-radius, 1px));
            background-size: var(--slider-step-px, 12px) var(--slider-step-px, 12px);
            background-position: calc(var(--slider-step-px, 12px) / 2) 50%;
            background-repeat: repeat-x;
            z-index: 1;
            pointer-events: none;
        }
        .slider-fill {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 0%;
            /* Fallback for browsers without OKLCH gradient support */
            background: linear-gradient(to right, var(--progress-color1), var(--progress-color2));
            /* Prefer OKLCH interpolation where supported for smoother, perceptually uniform gradients */
            background: linear-gradient(to right in oklch, var(--progress-color1), var(--progress-color2));
            border-radius: inherit;
            z-index: 2;
        }
        .slider-thumb {
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
            width: var(--slider-thumb-size, 22px);
            height: var(--slider-thumb-size, 22px);
            background: var(--slider-thumb-color, var(--progress-color2));
            border-radius: 50%;
            aspect-ratio: 1 / 1;
            box-sizing: content-box;
            pointer-events: auto; /* ensure clicks on protruding half are captured */
            touch-action: none;
            cursor: pointer;
            z-index: 2; /* ensure thumb sits above fill */
        }
        .slider-value {
            flex: 0 0 var(--slider-value-width, 48px);
            width: var(--slider-value-width, 48px);
            text-align: right;
            display: inline-block;
            white-space: nowrap;
        }
        .slider-value:empty { display: none; }
        .slider-step-btn {
            flex: 0 0 auto;
            width: 30px;
            height: 30px;
            border: none;
            background: transparent;
            color: var(--progress-color1);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 30px; /* doubled */
            line-height: 1;
            padding: 0;
            border-radius: 0;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
            font-weight: 400;
        }
        .slider-step-btn[data-dir="-1"] { color: var(--progress-color1); }
        .slider-step-btn[data-dir="1"] { color: var(--progress-color1); }
        .slider-step-btn:hover { transform: scale(1.0); opacity: 1; }

        .progress-text {
            position: absolute;
            top: 1px;
            left: 0;
            right: 0;
            bottom: 0px;
            z-index: 2;
            display: var(--progress-bar-show-text, flex);
            justify-content: space-between;
            align-items: center;
            padding: 0 var(--progress-bar-text-padding, 12px);
            white-space: nowrap;
            overflow: hidden;
        }

        /* Target SOC marker overlay (mirrors Wallbox zielsoc marker) */
        .progress-container .target-marker {
            position: absolute;
            top: 0;
            bottom: 0;
            left: calc(var(--target-percent, -1000%) - 4px);
            width: 8px;
            pointer-events: none;
            z-index: 1;
            background: none;
        }
        .progress-container .soc-triangle {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 3px solid transparent;
            border-right: 3px solid transparent;
            opacity: 0.3;
        }
        .progress-container .soc-triangle-top {
            top: 0;
            border-bottom: 0;
            border-top: 3px solid #000;
        }
        .progress-container .soc-triangle-bottom {
            bottom: 0;
            border-top: 0;
            border-bottom: 3px solid #000;
        }
        .progress-container .target-marker-text {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            left: calc(var(--target-percent, 0%) + 5px);
            color: inherit;
            z-index: 2;
            font-size: var(--balkenschriftgroesse, inherit);
            line-height: 1em;
            display: inline-flex;
            align-items: center;
            padding: 0 5px;
            white-space: nowrap;
            visibility: visible;
        }
        .progress-container .target-marker-text.position-before-bar {
            left: auto;
            right: calc(100% - var(--target-percent, 0%) + 5px);
        }

        .progress-main-text {
            flex: 1;
            text-align: left;
            margin-right: 8px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .progress-second-variable {
            flex-shrink: 0;
            text-align: right;
            margin-left: 8px;
        }

        /* Spezielle Ausrichtung für Icons in Progress-Balken */
        .progress-text .variable-icon {
            vertical-align: text-bottom;
            align-self: center;
            display: inline-flex;
            align-items: center;
            transform: translateY(-1px); /* Icon 1px höher */
            margin-top: 0 !important; /* Überschreibe allgemeine Icon-Margins */
            margin-bottom: 0 !important; /* Überschreibe allgemeine Icon-Margins */
        }
        /* Gleiche Ausrichtung auch für Marker-Text-Icons anwenden */
        .progress-container .target-marker-text .variable-icon {
            vertical-align: text-bottom;
            align-self: center;
            display: inline-flex;
            align-items: center;
            transform: translateY(-1px);
            font-size: 1em;
            width: 1em;
            height: 1em;
            margin-top: 0 !important;
            margin-bottom: 0 !important;
            margin-right: 4px; /* kleiner Abstand vor Label */
        }
        .progress-container .target-marker-text svg[class*="fa-"] {
            width: 1em;
            height: 1em;
        }
        
        /* Labels in Progress-Bars: Keine störenden Margins */
        .progress-text .variable-label {
            margin-top: 0 !important;
            margin-bottom: 0 !important;
        }

        .no-wrap {
            white-space: nowrap;
        }

        /* Spezielle Styles für verschiedene Variablentypen */
        .variable-text {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin: calc(var(--element-spacing, 8px) ) 0;
        }
        
        /* Text-Variablen: 5px mehr Top- und Bottom-Margin als andere Darstellungen */
        .variable-text {
            margin: calc(var(--element-spacing, 8px) ) 0;
        }
        
        /* Optionale Grenzlinie unter Textvariablen */
        .variable-item.with-border-line {
            border-bottom: 1px solid color-mix(in srgb, var(--accent-color) 50%, transparent);
            padding-bottom: 0px;
            margin-bottom: 0px;
        }

        
        /* Linie unter Gruppen wenn showLine aktiviert ist */
        .group-line {
            width: 100%;
            border-bottom: 1px solid color-mix(in srgb, var(--accent-color) 50%, transparent);
            margin-top: 0px;
            margin-bottom: 8px;
        }
        
        /* Stretch-Modus für Gruppen-Buttons - Robuste CSS-Lösung */
        
        /* Container-Level: Stretch-Gruppen brauchen volle Breite */
        .variable-group.stretch-buttons {
            width: 100% !important;
            display: flex !important;
        }
        
        /* Items-Container: Flex-Layout mit korrektem Gap */
        .variable-group.stretch-buttons .variable-group-items {
            display: flex !important;
            width: 100% !important;
            gap: 16px !important;
            flex-wrap: nowrap !important;
            column-gap: 16px !important;
            row-gap: calc(var(--element-spacing, 8px)) !important;
            align-items: flex-start; /* Inline-Styles können Ausrichtung bei Bedarf überschreiben */
        }
        
        /* === REINE BOOL-GRUPPEN: Gleichmäßige Verteilung === */
        
        /* Reine Bool-Gruppen: Items gleichmäßig verteilen */
        .variable-group.stretch-buttons:not(:has(.variable-multi-button-container)) .variable-group-item {
            flex: 1 !important;
            display: flex !important;
            min-width: 0 !important;
        }
        
        /* Reine Bool-Gruppen: Button-Container volle Breite */
        .variable-group.stretch-buttons:not(:has(.variable-multi-button-container)) .variable-group-item .variable-button-container {
            width: 100% !important;
            display: flex !important;
            /* Margins beibehalten für konsistente vertikale Abstände */
        }

        /* Reine Bool-Gruppen: Buttons volle Container-Breite */
        .variable-group.stretch-buttons:not(:has(.variable-multi-button-container)) .variable-group-item .variable-button-container .variable-button {
            width: 100% !important;
            min-width: 100% !important;
            max-width: 100% !important;
        }

        /* Fallback ohne :has() Unterstützung – immer volle Breite für Bool-Buttons in Stretch-Gruppen */
        .variable-group.stretch-buttons .variable-group-item .variable-button-container {
            width: 100% !important;
            display: flex !important;
        }
        .variable-group.stretch-buttons .variable-group-item .variable-button-container .variable-button {
            width: 100% !important;
            min-width: 0 !important;
            max-width: 100% !important;
            flex: 1 1 0% !important; /* Ensure buttons fill width */
        }
        
        
        /* === GEMISCHTE GRUPPEN: Bool feste Breite, Integer restlicher Platz === */
        
        /* Gemischte Gruppen: Bool-Button Items feste Breite */
        .variable-group.stretch-buttons:has(.variable-multi-button-container) .variable-group-item:has(.variable-button-container) {
            display: flex !important;
        }
        /* Gemischte Gruppen: Bool-Button Container */
        .variable-group.stretch-buttons:has(.variable-multi-button-container) .variable-group-item .variable-button-container {
            display: flex !important;
            /* Margins beibehalten für konsistente vertikale Abstände */
            /* Keine width: 100% - Button behält seine konfigurierte Breite */
        }
        
        /* Gemischte Gruppen: Bool-Buttons behalten buttonWidth */
        .variable-group.stretch-buttons:has(.variable-multi-button-container) .variable-group-item .variable-button-container .variable-button {
            /* Bool-Button behält seine eingestellte Button Width - explizit keine Überschreibung der width */
            /* width wird durch Inline-Styles aus buttonWidth gesetzt - nicht überschreiben */
            max-width: none !important;
        }
        
        /* Gemischte Gruppen: Integer/String Items nutzen restlichen Platz */
        .variable-group.stretch-buttons:has(.variable-multi-button-container) .variable-group-item:has(.variable-multi-button-container) {
            flex: 1 !important;
            display: flex !important;
            min-width: 0 !important;
        }
        
        /* Multi-Button-Container für Integer/String-Variablen */
        .variable-group.stretch-buttons .variable-group-item .variable-multi-button-container {
            width: 100% !important;
            display: flex !important;
            align-items: stretch !important; /* ensure buttons fill height */
            /* Margins beibehalten für konsistente vertikale Abstände */
        }
        
        /* Multi-Buttons: Gleichmäßige Verteilung innerhalb des Containers */
        .variable-group.stretch-buttons .variable-group-item .variable-multi-button-container .variable-multi-button {
            /* Equal distribution across container; flex-basis:0 for Safari/WebKit */
            flex: 1 1 0% !important;
            min-width: 0 !important;
            width: auto !important;
            display: flex !important; /* avoid inline-flex + abs overlay quirks */
            align-items: center !important;
        }
        

        
        /* Spezifische Regel für gruppierte Text-Variablen: Überschreibt die 0-Margin-Regel */
        .variable-group-item .variable-item.text-variable {
            display: inline-flex; /* Sicherstellen, dass Elemente in einer Zeile bleiben */
            flex-direction: row;
            margin-bottom: 0px; /* +5px mehr Abstand auch für gruppierte */
            margin-top: 0px; /* +5px mehr Abstand auch für gruppierte */
            white-space: nowrap; /* Icon, Label, Value in einer Zeile halten */
            width: auto; /* Nur Inhaltsbreite einnehmen, darf schrumpfen */
            gap: 0px; /* Abstand über Icon-Margin, identisch zu ungruppierten Texten */
            align-items: baseline; /* Zahlen auf Basislinie zum Label */
        }
        .variable-group-item .variable-item.text-variable .variable-icon,
        .variable-group-item .variable-item.text-variable .variable-label,
        .variable-group-item .variable-item.text-variable .variable-value {
            display: inline-flex; /* Kinder ebenfalls inline darstellen */
            white-space: nowrap; /* Sicherheit: keine Zeilenumbrüche */
            margin: 0; /* Keine vertikalen Margins innerhalb der Zeile */
        }
        .variable-group-item .variable-item.text-variable .variable-value {
            flex: 0 0 auto; /* Wachstum verhindern */
            min-width: 0; /* Schrumpfen zulassen */
        }
        /* Gleicher Icon-Abstand wie ungruppiert: nur rechts 5px, keine vertikalen Margins */
        .variable-group-item .variable-item.text-variable .variable-icon {
            margin-right: 5px;
            margin-top: 0;
            margin-bottom: 0;
        }

        .variable-progress {
            width: 100%;
            display: flex;
            align-items: center; /* Vertikale Zentrierung für Progress-Balken */
            justify-content: center; /* Horizontale Zentrierung */
        }

        .variable-button-container {
            margin-bottom: var(--element-spacing, 8px); /* Einheitlicher vertikaler Abstand */
            margin-top: var(--element-spacing, 8px); /* Einheitlicher vertikaler Abstand */
            display: flex;
            align-items: center; /* Vertikale Zentrierung für Button-Container */
            width: 100%;
        }

        /* Button-Styles für Bool-Variablen */
        .variable-button {
            display: inline-flex;
            align-items: center;
            height: var(--button-height, 25px);
            padding: 0 12px;
            border: none;
            border-radius: var(--progress-bar-border-radius, 10px);
            background-color: #f8f9fa;
            color: #333;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: inherit;
            font-weight: 500;
            user-select: none;
            min-width: 80px;
            justify-content: center;
            box-sizing: border-box;
            position: relative; /* needed for ::after overlay */
            overflow: hidden;  /* clip overlay to rounded corners */
            z-index: 0; /* establish stacking context below overlay */
            /* iOS/WebKit: ensure custom background covers full button area */
            -webkit-appearance: none;
            appearance: none;
            -moz-appearance: none;
               background-clip: padding-box;
        }

        /* Multi-Button-Container für Integer-Variablen */
        .variable-multi-button-container {
            display: flex;
            gap: 1px; /* Reduzierter Abstand für Button-Gruppierung */
            align-items: center;
            width: 100%;
        }

        /* Einzelne Buttons in Multi-Button-Container */
        .variable-multi-button {
            display: inline-flex;
            align-items: center;
            height: var(--button-height, 25px);
            padding: 0 8px;
            border: none;
            border-radius: var(--progress-bar-border-radius, 10px);
            background-color: #f8f9fa;
            color: #333;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: inherit;
            font-weight: 500;
            user-select: none;
            min-width: 60px;
            justify-content: center;
            box-sizing: border-box;
            flex: 0 0 auto; /* Verhindere automatisches Stretching, respektiere explizite Breite */
            position: relative; /* needed for ::after overlay */
            overflow: hidden;  /* clip overlay to rounded corners */
            z-index: 0; /* establish stacking context below overlay */
            /* iOS/WebKit: ensure custom background covers full button area */
            -webkit-appearance: none;
            appearance: none;
            -moz-appearance: none;
            -webkit-tap-highlight-color: transparent;
            background-clip: padding-box;
        }

        .variable-multi-button:hover {
            opacity: 0.8;
        }

        .variable-multi-button.active {
            font-weight: 600;
        }

        /* Explicit inactive state overlay to force full-surface dimming on mobile/webviews */
        .variable-button.inactive::after,
        .variable-multi-button.inactive::after {
            content: '';
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.5);
            border-radius: inherit;
            pointer-events: none;
            z-index: 1;
        }

        /* Button-Gruppierung: Spezielle Border-Radius für zusammenhängende Button-Gruppe */
        .variable-multi-button.first-button {
            border-radius: var(--progress-bar-border-radius, 10px) 0 0 var(--progress-bar-border-radius, 10px); /* Nur links rund */
        }

        .variable-multi-button.middle-button {
            border-radius: 0; /* Keine runden Ecken */
        }

        .variable-multi-button.last-button {
            border-radius: 0 var(--progress-bar-border-radius, 10px) var(--progress-bar-border-radius, 10px) 0; /* Nur rechts rund */
        }

        .variable-multi-button.single-button {
            border-radius: var(--progress-bar-border-radius, 10px); /* Alle Ecken rund wenn nur ein Button */
        }

        
        /* Status-Bereich Styles */
        .status-container {
            margin-bottom: var(--element-spacing, 8px);
            padding: 0px 0;
        }

        .status-label {
            font-weight: bold;
            margin-right: 0px;
        }

        .status-value {
            color: var(--status-color, #000000);
        }

        .status-icon {
            margin-right: 8px;
            width: 16px;
            height: 16px;
        }

        .status-image {
            width: 16px;
            height: 16px;
        }

        /* FontAwesome Icon Styles */
        .fontawesome-icon-container {
            display: flex;
            align-items: center;
            /* WICHTIG: Container darf nicht volle Breite einnehmen, damit .div1 justify-content wirkt */
            flex: 0 0 auto;
            width: auto;
            color: var(--content-color, #000000);
        }

        .fontawesome-icon-container i[class*="fa-"],
        .fontawesome-icon-container svg[class*="fa-"] {
            color: inherit;
            display: inline-block;
            line-height: 1;
        }

        /* Icon size anpassbar basierend auf Container */
        .div1 .fontawesome-icon-container i[class*="fa-"],
        .div1 .fontawesome-icon-container svg[class*="fa-"] {
            font-size: var(--bildbreite, 48px);
            width: var(--bildbreite, 48px);
            height: var(--bildbreite, 48px);
        }
    </style>

    <script>

        
        // Icons werden direkt vom Server gemappt, wir müssen nur noch die richtigen CSS-Klassen hinzufügen
        
        // Bereite ein Icon für die Verwendung im Frontend vor
        function prepareIconForDisplay(iconName) {
            // Wenn kein Icon oder leerer String, nichts zurückgeben
            if (!iconName || iconName === 'Transparent' || iconName === '') {
                return '';
            }
            
            // Das Icon wurde bereits auf dem Server gemappt, wir müssen nur sicherstellen
            // dass das richtige Präfix vorhanden ist
            let iconClass = iconName;
            
            // Respektiere vorhandene Prefixe (inkl. fa-kit/fak) und ergänze nur fa-fw
            const hasPrefix =
                iconClass.startsWith('fa-light ') ||
                iconClass.startsWith('fa-solid ') ||
                iconClass.startsWith('fa-regular ') ||
                iconClass.startsWith('fa-brands ') ||
                iconClass.startsWith('fas ') ||
                iconClass.startsWith('far ') ||
                iconClass.startsWith('fal ') ||
                iconClass.startsWith('fab ') ||
                iconClass.startsWith('fa-kit ') ||
                iconClass.startsWith('fak ');

            if (hasPrefix) {
                if (!iconClass.includes('fa-fw')) {
                    iconClass = 'fa-fw ' + iconClass;
                }
                return iconClass;
            }

            // Kein Prefix angegeben: Versuche dynamisch das verfügbare Set zu finden (Kit → Solid → Regular → Light → Brands)
            const styles = [
                { classes: 'fa-kit fak', find: 'fak' },
                { classes: 'fa-solid',  find: 'fas' },
                { classes: 'fas',       find: 'fas' },
                { classes: 'fa-regular',find: 'far' },
                { classes: 'far',       find: 'far' },
                { classes: 'fa-light',  find: 'fal' },
                { classes: 'fal',       find: 'fal' },
                { classes: 'fa-brands', find: 'fab' },
                { classes: 'fab',       find: 'fab' },
            ];

            const baseName = iconClass.startsWith('fa-') ? iconClass.substring(3) : iconClass;

            if (window.FontAwesome && typeof window.FontAwesome.findIconDefinition === 'function') {
                for (const s of styles) {
                    try {
                        const def = window.FontAwesome.findIconDefinition({ prefix: s.find, iconName: baseName });
                        if (def) {
                            return `fa-fw ${s.classes} fa-${baseName}`;
                        }
                    } catch (e) {
                        // continue
                    }
                }
            }

            // Fallback: bevorzuge Kit, ansonsten Solid
            return `fa-fw fa-kit fak fa-${baseName}`;
        }
        
        // Globaler Spin-State pro Button-Ident (nur Script-Buttons)
        window._scriptButtonSpinUntil = window._scriptButtonSpinUntil || {};
        
        // === Button-Icon Spin Helper ===
        function startButtonIconSpin(buttonEl) {
            if (!buttonEl) return;
            // Entferne FA-Kommentare (<!-- i ... -->), die i2svg hinterlässt
            try {
                const childNodes = Array.from(buttonEl.childNodes);
                for (const n of childNodes) {
                    if (n.nodeType === 8) { // Kommentar
                        buttonEl.removeChild(n);
                    }
                }
            } catch (_) {}
            // Script-Buttons während des Spins optisch aktiv setzen
            if (buttonEl.dataset && buttonEl.dataset.scriptButton === '1') {
                try {
                    // Entferne inaktiv-Status für die Spin-Dauer
                    if (buttonEl.classList) {
                        buttonEl.classList.remove('inactive');
                        buttonEl.classList.add('active');
                    }
                } catch (_) {}
            }
            // Ersten vorhandenen Icon-Knoten (svg oder i) ermitteln
            let icon = buttonEl.querySelector('i[class*="fa-"], svg[class*="fa-"]');
            if (icon) {
                // Ursprüngliches Icon-HTML sichern und Icon-Knoten entfernen
                if (!buttonEl.dataset.originalIconHtml) {
                    try { buttonEl.dataset.originalIconHtml = icon.outerHTML; } catch (_) {}
                }
                try { icon.remove(); } catch (_) {}
            }
            // Neues Spinner-Icon einfügen; verwende FA "rotate" als Glyph
            const temp = document.createElement('i');
            const tempBase = prepareIconForDisplay('rotate') || 'fa-fw fa-kit fak fa-rotate';
            temp.className = `${tempBase} fa-spin`;
            temp.setAttribute('data-temp-spinner', '1');
            temp.style.marginRight = '6px';
            try { buttonEl.insertBefore(temp, buttonEl.firstChild); } catch (_) { buttonEl.appendChild(temp); }
            // Sofortige Konvertierung von <i> zu <svg>, falls FA Kit verfügbar ist
            try {
                if (window.FontAwesome && window.FontAwesome.dom && typeof window.FontAwesome.dom.i2svg === 'function') {
                    window.FontAwesome.dom.i2svg({ node: temp, observeMutations: false });
                }
            } catch (_) {}
        }

        function stopButtonIconSpin(buttonEl) {
            if (!buttonEl) return;
            // Entferne Spinner (konvertiert evtl. zu <svg>) – identifiziere über fa-spin
            try {
                const spinIcons = buttonEl.querySelectorAll('svg.fa-spin, i.fa-spin');
                spinIcons.forEach(node => node.remove());
            } catch (_) {}
            // Entferne evtl. verbliebene FA-Kommentar-Knoten
            try {
                const childNodes = Array.from(buttonEl.childNodes);
                for (const n of childNodes) {
                    if (n.nodeType === 8) {
                        buttonEl.removeChild(n);
                    }
                }
            } catch (_) {}
            // Script-Buttons sollen optisch IMMER aktiv bleiben
            if (buttonEl.dataset && buttonEl.dataset.scriptButton === '1') {
                try {
                    if (buttonEl.classList) {
                        buttonEl.classList.remove('inactive');
                        buttonEl.classList.add('active');
                    }
                } catch (_) {}
            }
            // Ursprüngliches Icon (falls gesichert) wiederherstellen
            try {
                const html = buttonEl.dataset.originalIconHtml;
                if (html && typeof html === 'string' && html.length > 0) {
                    const wrapper = document.createElement('div');
                    wrapper.innerHTML = html;
                    const restored = wrapper.firstElementChild;
                    if (restored) {
                        restored.style.marginRight = restored.style.marginRight || '6px';
                        buttonEl.insertBefore(restored, buttonEl.firstChild);
                        // Falls es ein <i> war, direkt konvertieren
                        try {
                            if (restored.tagName.toLowerCase() === 'i' && window.FontAwesome && window.FontAwesome.dom && typeof window.FontAwesome.dom.i2svg === 'function') {
                                window.FontAwesome.dom.i2svg({ node: restored, observeMutations: false });
                            }
                        } catch (_) {}
                    }
                }
                delete buttonEl.dataset.originalIconHtml;
            } catch (_) {}
        }

        function handleButtonClick(buttonEl, ident, value) {
            try {
                const openObjectIdAttr = buttonEl && buttonEl.dataset ? buttonEl.dataset.openObjectId : null;
                const openObjectId = openObjectIdAttr ? parseInt(openObjectIdAttr, 10) : 0;
                if (openObjectId > 0 && typeof openObject === 'function') {
                    openObject(openObjectId);
                    return;
                }
            } catch (_) {}

            const shouldSpin = (typeof ident === 'string' && ident.indexOf('script_') === 0);
            if (shouldSpin) {
                try {
                    window._scriptButtonSpinUntil = window._scriptButtonSpinUntil || {};
                    const spinUntil = Date.now() + 5000;
                    window._scriptButtonSpinUntil[ident] = spinUntil;
                    startButtonIconSpin(buttonEl);
                    setTimeout(() => {
                        try {
                            if (!window._scriptButtonSpinUntil) {
                                stopButtonIconSpin(buttonEl);
                                return;
                            }
                            const current = window._scriptButtonSpinUntil[ident];
                            if (!current || current <= Date.now()) {
                                delete window._scriptButtonSpinUntil[ident];
                                stopButtonIconSpin(buttonEl);
                            }
                        } catch (_) {}
                    }, 5200);
                } catch (_) {}
            }
            try {
                if (typeof requestAction === 'function') {
                    requestAction(ident, value);
                } else {
                    console.error('requestAction is not available');
                }
                // Optimistic UI: unmittelbar den Button-Status updaten
                try {
                    if (!shouldSpin) {
                        // Kein Optimistic-Update: Anzeige erst nach Backend-Update ändern
                    }
                } catch (_) {}
            } catch (e) {
                console.error(e);
            }

            // Nach Text-Änderungen Kollisionen neu prüfen und Marker ggf. wieder einblenden
            try {
                const progressContainer = progressTextContainer.closest('.progress-container');
                if (progressContainer) {
                    updateTargetMarkerDisplay(progressContainer, variable);
                }
            } catch (_) {}
        }
        
        // Hilfsfunktion zur Bestimmung der Textfarbe
        function getTextColor(variable) {
            // Verwende --content-color wenn TextColor transparent ist, ansonsten die konfigurierte Farbe
            if (variable.isTextColorTransparent) {
                return 'var(--content-color)';
            }
            return variable.textColor;
        }

        // Hilfsfunktion zur Anwendung der Bildposition
        function applyImagePosition(position) {
            const mainContainer = document.querySelector('.main_container');
            if (!mainContainer) {
                return;
            }
            
            // Entferne alle bisherigen Bildpositions-Klassen
            mainContainer.classList.remove('image-left', 'image-right', 'image-top', 'image-bottom');
            
            // Füge die entsprechende Klasse hinzu
            switch (position) {
                case 'left':
                    mainContainer.classList.add('image-left');
                    break;
                case 'right':
                    mainContainer.classList.add('image-right');
                    break;
                case 'top':
                    mainContainer.classList.add('image-top');
                    break;
                case 'bottom':
                    mainContainer.classList.add('image-bottom');
                    break;
                default:
                    // Fallback auf links
                    mainContainer.classList.add('image-left');
                    break;
            }
        }

        // Hilfsfunktion zur Bildanzeige-Steuerung basierend auf Bildauswahl und Bildbreite
        function updateImageVisibility() {
            const div1 = document.getElementById('div1');
            const div2 = document.getElementById('div2');
            const mainContainer = document.querySelector('.main_container');
            const bildauswahl = window.currentBildauswahl;
            const bildbreite = window.currentBildbreite;
            
            // Only handle COLUMN hiding vs showing - let renderStatus() handle individual image content
            const hideImageColumn = window.hideImageColumn || false;
            
            if (hideImageColumn) {
                // Hide ENTIRE COLUMN when backend determines no images should be shown
                if (div1) {
                    div1.style.display = 'none';
                    div1.className = 'hidden';
                }
                if (div2) {
                    div2.style.padding = '0px';
                    div2.style.width = '100%'; // div2 nimmt gesamte Breite ein
                }
            } else {
                // Show COLUMN - renderStatus() will handle individual image/icon content exclusively
                if (div1) {
                    div1.style.display = 'block';
                    div1.className = 'div1';
                    // WICHTIG: Hier NICHT das #image sichtbar schalten.
                    // Sonst kann kurzzeitig ein leeres Bild (blaues Quadrat) sichtbar werden,
                    // bevor renderStatus() das tatsächliche Icon/Bild setzt.
                }
                if (div2) {
                    div2.style.width = '100%'; // div2 bleibt flexibel
                }
            }
        }

        function updateProgressBarStyles(config) {
            const root = document.documentElement;
            
            // Setze CSS-Variablen für die zentrale Konfiguration
            root.style.setProperty('--progress-bar-height', config.height + 'px');
            root.style.setProperty('--progress-bar-border-radius', config.borderRadius + 'px');
            
            // Konvertiere Hintergrundfarbe zu rgba mit Transparenz
            const bgColor = config.backgroundColor;
            const opacity = config.backgroundOpacity;
            
            // Extrahiere RGB-Werte aus Hex-Farbe
            const r = parseInt(bgColor.substr(1, 2), 16);
            const g = parseInt(bgColor.substr(3, 2), 16);
            const b = parseInt(bgColor.substr(5, 2), 16);
            const rgbaColor = `rgba(${r}, ${g}, ${b}, ${opacity})`;
            
            root.style.setProperty('--progress-bar-bg-color', rgbaColor);
            root.style.setProperty('--progress-bar-bg-opacity', '1'); // Opacity bereits in rgba enthalten
            // Dynamisches Padding basierend auf Textgröße: Padding = fontSize / 2
            const fontSize = parseInt(getComputedStyle(document.documentElement).fontSize) || 12;
            const dynamicPadding = Math.max(4, Math.round(fontSize / 1)); // Minimum 4px
            root.style.setProperty('--progress-bar-text-padding', dynamicPadding + 'px');
            root.style.setProperty('--progress-bar-show-text', config.showText ? 'flex' : 'none');
        }

        function updateButtonStyles(config) {
            const root = document.documentElement;
            
            // Setze CSS-Variable für die zentrale Button-Konfiguration
            root.style.setProperty('--button-height', config.height + 'px');
        }

        function handleMessage(data) {
            let decodedData;
            if (typeof data === 'string') {
                try {
                    decodedData = JSON.parse(data);
                } catch (e) {
                    console.error('handleMessage: invalid JSON string', data, e);
                    return;
                }
            } else if (data && typeof data === 'object') {
                decodedData = data; // already parsed object
            } else {
                console.error('handleMessage: unsupported data type', typeof data, data);
                return;
            }
            const root = document.documentElement;
            

            
            // Setze InstanceID für RequestAction-Aufrufe
            if (decodedData.instanceid) {
                window.InstanceID = decodedData.instanceid;
            }

            // 🚀 BATCH-RENDERING: Flag um nur einmal zu rendern
            let needsRerender = false;

            // Verarbeite die neuen Parameter
            for (const parameter in decodedData) {
                const value = decodedData[parameter];
                
                switch (parameter.toLowerCase()) {
                    case 'debugenabled':
                        debugEnabled = value;
                        break;
                    case 'elementspacing':
                        // Setze CSS-Variable für element-spacing
                        root.style.setProperty('--element-spacing', value + 'px');
                        break;
                    case 'bildposition':
                        // Bildposition-Konfiguration verarbeiten
                        applyImagePosition(value);
                        break;
                    case 'showborderline':
                        // Trennlinie ein-/ausblenden
                        const mainContainer = document.querySelector('.main_container');
                        if (mainContainer) {
                            if (value) {
                                mainContainer.classList.remove('hide-border-line');
                            } else {
                                mainContainer.classList.add('hide-border-line');
                            }
                        }
                        break;
                    case 'image1url':
                        // Hintergrundbild direkt per WebHook-URL setzen (Browser-Caching aktiv)
                        try {
                            if (typeof value === 'string' && value) {
                                const mainDiv = document.querySelector('body');
                                mainDiv.style.setProperty('--background-image', 'url(' + value + ')');
                                window._bgImageFromUrl = true;
                            }
                        } catch (_) {}
                        break;
                    case 'image1':
                        try {
                            if (typeof value === 'string' && value) {
                                const mainDiv = document.querySelector('body');
                                if (!window._bgImageFromUrl) {
                                    mainDiv.style.setProperty('--background-image', 'url(' + value + ')');
                                }
                            }
                        } catch (_) {}
                        break;

                    case 'imagealignment':
                        // Speichere Alignment global und wende sofort an
                        window.currentImageAlignment = value;
                        
                        // Wende Alignment sofort an - gilt für Bild ODER Icon
                        const div1 = document.querySelector('.main_container .div1');
                        const alignmentContainer = document.querySelector('.main_container');
                        const imgElement = document.querySelector('.main_container .div1 img');
                        const iconContainerLive = document.querySelector('.main_container .div1 .fontawesome-icon-container');
                        
                        if (div1 && alignmentContainer) {
                            // Stelle sicher, dass flex-Kontext vorhanden ist (für alle Positionen)
                            div1.style.display = 'flex';
                            switch (value) {
                                case 'left':
                                    div1.style.justifyContent = 'flex-start';
                                    break;
                                case 'center':
                                    div1.style.justifyContent = 'center';
                                    break;
                                case 'right':
                                    div1.style.justifyContent = 'flex-end';
                                    break;
                                default:
                                    div1.style.justifyContent = 'center';
                            }
                            
                            // Für IMG zusätzlich Margin setzen (visuelle Sicherheit)
                            if (imgElement) {
                                switch (value) {
                                    case 'left':
                                        imgElement.style.margin = '0 auto 0 0';
                                        break;
                                    case 'center':
                                        imgElement.style.margin = '0 auto';
                                        break;
                                    case 'right':
                                        imgElement.style.margin = '0 0 0 auto';
                                        break;
                                    default:
                                        imgElement.style.margin = '0 auto';
                                }
                            }
                            // Für Icon-Container: justify-content entsprechend setzen
                            if (iconContainerLive) {
                                switch (value) {
                                    case 'left':
                                        iconContainerLive.style.justifyContent = 'flex-start';
                                        break;
                                    case 'center':
                                        iconContainerLive.style.justifyContent = 'center';
                                        break;
                                    case 'right':
                                        iconContainerLive.style.justifyContent = 'flex-end';
                                        break;
                                    default:
                                        iconContainerLive.style.justifyContent = 'center';
                                }
                            }
                        }
                        break;
                    case 'status':
                    case 'statusvalue':
                    case 'statuscolor':
                    case 'statusalignment':
                    case 'statusBildauswahl':  
                        // Set global currentBildauswahl for updateImageVisibility
                        if (decodedData.hasOwnProperty('statusBildauswahl')) {
                            window.currentBildauswahl = decodedData.statusBildauswahl;
                        }

                        // Build a minimal comparable snapshot of all status-relevant props
                        const currentStatusSnapshot = {
                            status: decodedData.status,
                            statusValue: decodedData.statusValue,
                            statusFontSize: decodedData.statusFontSize,
                            statusAlignment: decodedData.statusAlignment,
                            statusShowIcon: decodedData.statusShowIcon,
                            statusShowLabel: decodedData.statusShowLabel,
                            statusShowValue: decodedData.statusShowValue,
                            statusLabel: decodedData.statusLabel,
                            statusIcon: decodedData.statusIcon,
                            statusBildauswahl: decodedData.statusBildauswahl,
                            statusIconColor: decodedData.statusIconColor,
                            isStatusIconColorTransparent: decodedData.isStatusIconColorTransparent,
                            statusColor: decodedData.statusColor,
                            isStatusColorTransparent: decodedData.isStatusColorTransparent,
                            statusHidden: decodedData.statusHidden,
                            hideImageColumn: decodedData.hideImageColumn,
                            imageAlignment: window.currentImageAlignment || null
                        };

                        const lastStatusSnapshotJson = window._lastStatusSnapshotJson || null;
                        const currentStatusSnapshotJson = JSON.stringify(currentStatusSnapshot);

                        if (lastStatusSnapshotJson !== currentStatusSnapshotJson) {
                            // Only re-render if something relevant changed
                            renderStatus(decodedData);
                            updateImageVisibility();
                            window._lastStatusSnapshotJson = currentStatusSnapshotJson;
                        }
                        
                        // Re-apply gespeicherte Bild-/Icon-Ausrichtung nach dem Rendering (Persistenz)
                        if (window.currentImageAlignment) {
                            const div1Restore = document.querySelector('.main_container .div1');
                            const imgRestore = document.querySelector('.main_container .div1 img');
                            const iconRestore = document.querySelector('.main_container .div1 .fontawesome-icon-container');
                            const mainContainerRestore = document.querySelector('.main_container');
                            
                            if (div1Restore && mainContainerRestore) {
                                // Justify-Content auf dem Container anwenden (wirkt für Icon und Bild) – für alle Positionen
                                div1Restore.style.display = 'flex';
                                switch (window.currentImageAlignment) {
                                    case 'left':
                                        div1Restore.style.justifyContent = 'flex-start';
                                        break;
                                    case 'center':
                                        div1Restore.style.justifyContent = 'center';
                                        break;
                                    case 'right':
                                        div1Restore.style.justifyContent = 'flex-end';
                                        break;
                                    default:
                                        div1Restore.style.justifyContent = 'center';
                                }
                                
                                // Für IMG zusätzlich Margin setzen
                                if (imgRestore) {
                                    switch (window.currentImageAlignment) {
                                        case 'left':
                                            imgRestore.style.margin = '0 auto 0 0';
                                            break;
                                        case 'center':
                                            imgRestore.style.margin = '0 auto';
                                            break;
                                        case 'right':
                                            imgRestore.style.margin = '0 0 0 auto';
                                            break;
                                        default:
                                            imgRestore.style.margin = '0 auto';
                                    }
                                }
                                // Für Icon-Container ebenfalls Margin setzen
                                if (iconRestore) {
                                    switch (window.currentImageAlignment) {
                                        case 'left':
                                            iconRestore.style.margin = '0 auto 0 0';
                                            break;
                                        case 'center':
                                            iconRestore.style.margin = '0 auto';
                                            break;
                                        case 'right':
                                            iconRestore.style.margin = '0 0 0 auto';
                                            break;
                                        default:
                                            iconRestore.style.margin = '0 auto';
                                    }
                                    // Und justify-content für den Icon-Container setzen
                                    switch (window.currentImageAlignment) {
                                        case 'left':
                                            iconRestore.style.justifyContent = 'flex-start';
                                            break;
                                        case 'center':
                                            iconRestore.style.justifyContent = 'center';
                                            break;
                                        case 'right':
                                            iconRestore.style.justifyContent = 'flex-end';
                                            break;
                                        default:
                                            iconRestore.style.justifyContent = 'center';
                                    }
                                }
                            }
                        }
                        break;
                    case 'hideimagecolumn':
                        // NEW: Handle hideImageColumn flag for complete image column visibility
                        if (decodedData.hasOwnProperty('hideImageColumn')) {
                            window.hideImageColumn = decodedData.hideImageColumn;
                            updateImageVisibility();
                        }
                        break;
                    case 'statusschriftgroesse':
                        renderStatus(decodedData);
                        break;
                    case 'statushidden':
                        // Neue Option: Statusbereich ausblenden, Funktionalität bleibt
                        renderStatus(decodedData);
                        break;
                    case 'variables':
                        // Skip processing if incoming variables payload is IDENTICAL to the previous one
                        if (window.lastVariablesData && JSON.stringify(value) === JSON.stringify(window.lastVariablesData)) {
                            needsRerender = false; // Nothing changed at all
                            break;
                        }

                        if (window.lastVariablesData && window.variableDataCache) {
                            let hasMinimalUpdates = false;
                            let hasOtherChanges = false;
                            

                            
                            // 🔧 FIX DATA STRUCTURE MISMATCH + DUPLICATE VARIABLE HANDLING: 
                            // Incoming value is array-indexed (0,1,2,3...) 
                            // Cache is variable-ID indexed (33670, 27157...)
                            // Same variable can appear multiple times with different displayTypes!
                            
                            const processedEntries = new Set(); // Track processed (id + displayType) combinations
                            const minimalUpdates = []; // Collect variables that can be updated minimally
                            
                            for (const arrayIndex in value) {
                                const newVariable = value[arrayIndex];
                                
                                // Find matching variable in cache by variable ID, not array index
                                const actualVariableId = newVariable?.variableId || newVariable?.id;
                                // Find matching old variable from previous payload by same id and displayType
                                let oldVariable = null;
                                try {
                                    if (window.lastVariablesData && actualVariableId) {
                                        const prev = window.lastVariablesData.find(v => (v?.variableId || v?.id) === actualVariableId && (v?.displayType || 'text') === (newVariable?.displayType || 'text'));
                                        if (prev) oldVariable = prev;
                                    }
                                } catch (_) { oldVariable = null; }
                                

                                
                                // 🎯 Handle duplicates by display type: process each (id + displayType) separately
                                const displayType = newVariable?.displayType || 'text';
                                const compositeKey = `${actualVariableId}::${displayType}`;
                                if (processedEntries.has(compositeKey)) {
                                    continue;
                                }
                                processedEntries.add(compositeKey);

                                // Always force a full re-render when image variables are present/updated
                                if (displayType === 'image') {
                                    hasOtherChanges = true;
                                }
                                
                                if (oldVariable && newVariable && actualVariableId) {
                                    // Prüfe ob sich nur rawValue oder formattedValue geändert hat
                                    const valueChanged = newVariable.rawValue !== oldVariable.rawValue;
                                    const formattedValueChanged = newVariable.formattedValue !== oldVariable.formattedValue;
                                    
                                    if (valueChanged || formattedValueChanged) {
                                        // Check display type and determine if minimal update is possible
                                        if (displayType === 'progress' || displayType === 'button' || displayType === 'text' || displayType === 'slider') {
                                            hasMinimalUpdates = true;
                                            minimalUpdates.push({ variableId: actualVariableId, type: displayType, variable: newVariable });
                                        } else {
                                            hasOtherChanges = true;
                                        }
                                    }
                                    // Prüfe andere Eigenschaften (but be less strict to avoid false positives)
                                    else if (JSON.stringify(newVariable) !== JSON.stringify(oldVariable)) {

                                        
                                        // Only mark as hasOtherChanges if it's a significant change (not just object reference)
                                        const significantChange = (
                                            newVariable.displayValue !== oldVariable.displayValue ||
                                            newVariable.unit !== oldVariable.unit ||
                                            newVariable.minValue !== oldVariable.minValue ||
                                            newVariable.maxValue !== oldVariable.maxValue
                                        );
                                        
                                        if (significantChange) {
                                            hasOtherChanges = true;
                                        }
                                    }
                                } else {
                                    hasOtherChanges = true; // Neue oder gelöschte Variable oder missing ID
                                }
                            }
                            
                            // Wenn nur Variable-Werte geändert haben (alle Typen), skip Full-Re-Render
                            if (hasMinimalUpdates && !hasOtherChanges) {
                                
                                // Führe Mini-Updates für alle geänderten Variablen durch
                                minimalUpdates.forEach((updateData) => {
                                    const { variableId, type, variable } = updateData;
                                    
                                    // Ensure cache reflects latest values for this variable before rendering
                                    try {
                                        if (!window.variableDataCache) window.variableDataCache = {};
                                        window.variableDataCache[variableId] = variable;
                                    } catch (_) {}

                                    switch (type) {
                                        case 'progress':
                                            updateProgressBarValue(variableId, variable.rawValue);
                                            break;
                                        case 'button':
                                            updateButtonValue(variableId, variable);
                                            break;
                                        case 'text':
                                            updateTextValue(variableId, variable);
                                            break;
                                        case 'slider':
                                            updateSliderValue(variableId, variable.rawValue);
                                            break;
                                    }
                                });
                                
                                // Update cache mit korrekter Datenstruktur
                                updateVariableCache(value);
                                window.lastVariablesData = value;
                                needsRerender = false; // 🚀 SKIP FULL RE-RENDER!
                                break;
                            }
                        } else {
                        }
                        
                        // Store latest variables and rebuild the ID-indexed cache for correct diffing next time
                        window.lastVariablesData = value;
                        updateVariableCache(value);
                        needsRerender = true;
                        break;
                    case 'progressbarconfig':
                        // Re-render nur, wenn sich die Konfiguration wirklich geändert hat
                        const newPbCfg = value || {};
                        const oldPbCfg = window.cachedProgressBarConfig || {};
                        if (JSON.stringify(newPbCfg) !== JSON.stringify(oldPbCfg)) {
                            updateProgressBarStyles(newPbCfg);
                            window.cachedProgressBarConfig = newPbCfg;
                            if (window.lastVariablesData) {
                                needsRerender = true;
                            }
                        }
                        break;
                    case 'buttonconfig':
                        // Re-render nur, wenn sich die Konfiguration wirklich geändert hat
                        const newBtnCfg = value || {};
                        const oldBtnCfg = window.cachedButtonConfig || {};
                        if (JSON.stringify(newBtnCfg) !== JSON.stringify(oldBtnCfg)) {
                            updateButtonStyles(newBtnCfg);
                            window.cachedButtonConfig = newBtnCfg;
                            if (window.lastVariablesData) {
                                needsRerender = true;
                            }
                        }
                        break;
                    case 'assets':
                        // Aktualisiere Assets (Bilder) sofort
                        if (typeof value === 'object') {
                            window.assets = window.assets || {};
                            Object.assign(window.assets, value);
                            try { console.info('[UDT] Assets updated:', Object.keys(value)); } catch(_) {}
                            // Wichtig: Wenn sich Medieninhalte geändert haben, muss das Statusbild neu gerendert werden,
                            // da das <img>-src bereits auf den alten base64-String gesetzt wurde.
                            // Re-render mit dem zuletzt bekannten Status-Payload.
                            try {
                                if (window._lastStatusPayload) {
                                    try { console.info('[UDT] Re-render status due to assets update (using last payload)'); } catch(_) {}
                                    renderStatus(window._lastStatusPayload);
                                    updateImageVisibility();
                                } else if (window.currentBildauswahl) {
                                    // Fallback: Kein gespeicherter Payload vorhanden -> Bild direkt aktualisieren
                                    const key = window.currentBildauswahl;
                                    let imageUrl = '';
                                    if (key && (key.startsWith('img_custom_') || key.startsWith('img_default_'))) {
                                        imageUrl = window.assets[key] || '';
                                    } else if (key && key !== 'none') {
                                        imageUrl = window.assets[`img_${key}`] || '';
                                    }
                                    const deviceImg = document.getElementById('image');
                                    if (deviceImg && imageUrl) {
                                        try { console.info('[UDT] Directly updating image src due to assets update'); } catch(_) {}
                                        deviceImg.style.display = 'none';
                                        deviceImg.onload = function() { this.style.display = ''; };
                                        deviceImg.onerror = function() { this.style.display = 'none'; };
                                        deviceImg.src = imageUrl;
                                    }
                                }
                            } catch (_) {}
                        }
                        break;
                    case 'imageVarUpdate':
                        // Minimal-Update vom Backend für Variablen mit displayType 'image'
                        try {
                            const updates = Array.isArray(value) ? value : [];
                            for (const u of updates) {
                                const id = u?.id;
                                const hookUrl = u?.imageUrl || '';
                                if (!id) continue;
                                const wrapper = document.querySelector(`.variable-item[data-variable-id="${CSS.escape(String(id))}"]`);
                                if (!wrapper) continue;
                                const img = wrapper.querySelector('img.variable-inline-image');
                                if (!img) continue;
                                img.style.display = 'none';
                                img.onload = function() { this.style.display = ''; };
                                img.onerror = function() { this.style.display = 'none'; };
                                try { img.decoding = 'async'; } catch (_) {}
                                try { img.loading = 'eager'; } catch (_) {}
                                if (hookUrl) { img.src = hookUrl; }
                                try {
                                    if (img.complete && img.naturalWidth > 0) {
                                        img.style.display = '';
                                    }
                                } catch (_) {}
                            }
                        } catch (_) {}
                        break;
                    case 'groupnames':
                        // Nur aktualisieren und re-rendern, wenn sich die Gruppennamen geändert haben
                        const newGroupNames = value || {};
                        const oldGroupNames = window.groupNames || {};
                        if (JSON.stringify(newGroupNames) !== JSON.stringify(oldGroupNames)) {
                            window.groupNames = newGroupNames;
                            if (window.lastVariablesData) {
                                needsRerender = true;
                            }
                        }
                        break;
                    case 'bildbreite':
                        root.style.setProperty('--bildbreite', value + 'px');
                        window.currentBildbreite = value;
                        updateImageVisibility();
                        break;
                    case 'bildtransparenz':
                        root.style.setProperty('--bildtransparenz', value);
                        break;
                    case 'kachelhintergrundfarbe':
                        if (value === '#FFFFFFFFFFFFFFFF') {
                            root.style.setProperty('--hintergrundfarbe', 'rgba(0, 0, 0, 0)');
                        } else {
                            root.style.setProperty('--hintergrundfarbe', value);
                        }
                        break;
                    
                    default:
                        // Handle minimal updates for SecondVariable (var_X_second*, var_X_second_value, var_X_second_icon)
                        if (parameter.startsWith('var_') && parameter.includes('_second')) {
                            const baseVarKey = parameter.split('_second')[0];
                            const targetVariableId = window.varKeyToIdMapping?.[baseVarKey];
                            if (targetVariableId && window.variableDataCache && window.variableDataCache[targetVariableId]) {
                                const variable = window.variableDataCache[targetVariableId];
                                variable.secondVariable = variable.secondVariable || {};
                                if (parameter.endsWith('_second_value')) {
                                    variable.secondVariable.rawValue = value;
                                } else if (parameter.endsWith('_second_icon')) {
                                    variable.secondVariable.icon = value;
                                } else {
                                    // formatted value update: 'var_X_second'
                                    variable.secondVariable.formattedValue = value;
                                }

                                // Wenn Marker aus SecondVariable verwendet wird, spiegle minimal Updates in progressTarget
                                try {
                                    if (variable.displayType === 'progress' && variable.useSecondVariableAsTarget) {
                                        variable.progressTarget = variable.progressTarget || {};
                                        if (parameter.endsWith('_second_value')) {
                                            variable.progressTarget.rawValue = value;
                                        } else if (!parameter.endsWith('_second_icon')) {
                                            // formatted text update
                                            variable.progressTarget.formattedValue = value;
                                        }
                                        // label aus secondVariable übernehmen, falls vorhanden
                                        if (variable.secondVariable && variable.secondVariable.label) {
                                            variable.progressTarget.label = variable.secondVariable.label;
                                        }
                                    }
                                } catch(_) {}

                                // For progress bars, update text and marker immediately (first update), width is based on main rawValue
                                if (variable.displayType === 'progress') {
                                    const progressContainers = document.querySelectorAll(`.progress-container[data-variable-id="${targetVariableId}"]`);
                                    progressContainers.forEach((progressContainer) => {
                                        const progressTextContainer = progressContainer.querySelector('.progress-text');
                                        if (progressTextContainer) {
                                            updateProgressText(progressTextContainer, variable);
                                        }
                                        updateTargetMarkerDisplay(progressContainer, variable);
                                    });
                                }
                            }
                            break; // handled in this branch
                        }
                        
                        // Prüfe auf Variable-Updates (Parameter endet mit '_value')
                        if (parameter.endsWith('_value')) {
                            // Extrahiere Variable-ID aus Parameter (z.B. 'var_3_value' -> 'var_3')
                            const varKey = parameter.replace('_value', '');
                            
                            // Aktualisiere rawValue im Cache
                            if (window.variableDataCache) {
                                const targetVariableId = window.varKeyToIdMapping[varKey];
                                if (targetVariableId) {
                                    if (window.variableDataCache[targetVariableId]) {
                                        window.variableDataCache[targetVariableId].rawValue = value;
                                    }
                                    // Direkt-Updates nach DOM-Präsenz, nicht nach Cache-DisplayType
                                    try {
                                        const hasProgress = document.querySelectorAll(`.progress-container[data-variable-id="${targetVariableId}"]`).length > 0;
                                        if (hasProgress) {
                                            updateProgressBarValue(targetVariableId, value);
                                        }
                                    } catch (_) {}
                                    try {
                                        const hasSlider = document.querySelectorAll(`.slider-container[data-variable-id="${CSS.escape(String(targetVariableId))}"]`).length > 0;
                                        if (hasSlider) {
                                            updateSliderValue(targetVariableId, value);
                                        }
                                    } catch (_) {}
                                }
                            }
                            
                            // Aktualisiere die entsprechende Variable (Button oder Text)
                            updateVariable(varKey, value, 'rawValue');
                        }
                        // Prüfe auf formatierte Werte (Parameter ist z.B. 'var_3')
                        else {
                            if (parameter.startsWith('var_') && !parameter.endsWith('_value')) {
                            
                            // Aktualisiere formatierte Werte im Cache
                            if (window.variableDataCache) {
                                const targetVariableId = window.varKeyToIdMapping?.[parameter];
                                if (targetVariableId && window.variableDataCache[targetVariableId]) {
                                    window.variableDataCache[targetVariableId].formattedValue = value;
                                    
                                    // Aktualisiere Variable-Darstellung mit neuem formatiertem Wert
                                    updateVariable(parameter, value, 'formattedValue');
                                }
                            }
                            }
                        }
                        break;
                }
            }

            // BATCH-RENDERING: Nur einmal rendern am Ende der Message-Verarbeitung
            if (needsRerender && window.lastVariablesData) {
                renderVariables(window.lastVariablesData);
            }
        }

        // Universelle Variable-Update-Funktion: aktualisiert ALLE Darstellungen (Text, Button, Progress, Slider) für die Variable
        function updateVariable(varKey, newValue, updateType) {
            // Find target variable ID using mapping
            if (!window.varKeyToIdMapping || !window.varKeyToIdMapping[varKey]) {
                return;
            }
            
            const targetVariableId = window.varKeyToIdMapping[varKey];
            
            // Finde Variable-Daten aus Cache
            if (!window.variableDataCache || !window.variableDataCache[targetVariableId]) {
                return;
            }
            
            const variable = window.variableDataCache[targetVariableId];
            
            // Update cache based on updateType
            if (updateType === 'rawValue') {
                variable.rawValue = newValue;
            } else if (updateType === 'formattedValue') {
                variable.formattedValue = newValue;
            }
            
            // Aktualisiere ALLE vorhandenen Darstellungen im DOM unabhängig vom gecachten displayType
            try { updateTextValue(targetVariableId, variable); } catch (_) {}
            try { updateButtonValue(targetVariableId, variable); } catch (_) {}
            try {
                const pc = document.querySelectorAll(`.progress-container[data-variable-id="${targetVariableId}"]`);
                if (pc && pc.length > 0) {
                    // Text & Marker aktualisieren
                    updateProgressDisplay(targetVariableId, variable);
                    // Breite auch bei formatierten Updates anpassen, falls möglich
                    if (updateType === 'formattedValue') {
                        let numeric = NaN;
                        try {
                            const s = String(newValue);
                            const m = s.match(/[-+]?\d+(?:[\.,]\d+)?/);
                            if (m) numeric = parseFloat(m[0].replace(',', '.'));
                        } catch (_) {}
                        if (!Number.isNaN(numeric)) {
                            updateProgressBarValue(targetVariableId, numeric);
                        }
                    }
                }
            } catch (_) {}
            try {
                const sc = document.querySelectorAll(`.slider-container[data-variable-id="${CSS.escape(String(targetVariableId))}"]`);
                if (sc && sc.length > 0) {
                    updateSliderValue(targetVariableId, variable.rawValue);
                }
            } catch (_) {}
        }
        
        // Hilfsfunktion für Button-Display-Update
        function updateButtonDisplay(buttonElement, variable) {
            
            // Resolve the multi-button container robustly (works if buttonElement is a button or any descendant)
            let multiButtonContainer = null;
            if (buttonElement) {
                if (buttonElement.classList && buttonElement.classList.contains('variable-multi-button-container')) {
                    multiButtonContainer = buttonElement;
                } else if (typeof buttonElement.closest === 'function') {
                    multiButtonContainer = buttonElement.closest('.variable-multi-button-container');
                } else {
                    // Fallback: try querySelector from a container element
                    try {
                        multiButtonContainer = buttonElement.querySelector && buttonElement.querySelector('.variable-multi-button-container');
                    } catch (_) {}
                }
            }
            
            // Support both Integer (variableType 1) and String (variableType 3) variables
            const associations = variable.variableAssociations || variable.integerAssociations;
            const isButtonVariable = (variable.variableType === 1 || variable.variableType === 3) && associations;
            
            if (multiButtonContainer && isButtonVariable) {
                // Integer/String variable: Update multi-buttons
                const currentValue = variable.variableType === 1 ? parseInt(variable.rawValue) : variable.rawValue;
                const buttons = multiButtonContainer.querySelectorAll('.variable-multi-button');
                
                buttons.forEach(button => {
                    const associationValue = variable.variableType === 1 ? 
                        parseInt(button.getAttribute('data-association-value')) : 
                        button.getAttribute('data-association-value');
                    const isActive = currentValue === associationValue;
                    
                    // Find the corresponding association for color and content
                    const association = associations.find(assoc => assoc.value === associationValue);
                    const buttonColor = association?.color || 'var(--accent-color)';
                    const opacity = isActive ? '1' : '0.5';
                    
                    // Update button state
                    button.style.backgroundColor = buttonColor;
                    // Do not set inline opacity; rely on classes for consistent full-surface dimming
                    // Maintain active/inactive classes (used by mobile to dim full surface)
                    if (isActive) {
                        button.classList.add('active');
                        button.classList.remove('inactive');
                    } else {
                        button.classList.remove('active');
                        button.classList.add('inactive');
                    }
                    
                    // Update button content based on display configuration
                    let buttonContentParts = [];
                    
                    // Icon
                    if (variable.showIcon && association?.icon && association.icon !== 'Transparent') {
                        const iconClass = prepareIconForDisplay(association.icon);
                        if (iconClass) {
                            buttonContentParts.push(`<i class="${iconClass}" style="margin-right: 6px;"></i>`);
                        }
                    }
                    
                    // Label and Value
                    if (variable.showLabel && association?.name) {
                        if (variable.showValue) {
                            // Label mit Doppelpunkt wenn auch Value gezeigt wird
                            buttonContentParts.push(`<span style="font-weight: 700;">${association.name}:&nbsp;</span>`);
                        } else {
                            // Nur Label ohne Doppelpunkt
                            buttonContentParts.push(`<span style="font-weight: 700;">${association.name}</span>`);
                        }
                    }
                    
                    if (variable.showValue) {
                        // Bei aktiven Buttons: aktueller Wert, bei inaktiven: Association-Name als Value
                        const displayValue = isActive ? variable.formattedValue : association?.name;
                        buttonContentParts.push(`<span style="font-weight: normal;">${displayValue}</span>`);
                    }
                    
                    // Falls keine Checkbox aktiviert ist, zeige Association-Name als Fallback
                    if (!variable.showIcon && !variable.showLabel && !variable.showValue && association?.name) {
                        buttonContentParts.push(`<span>${association.name}</span>`);
                    }
                    
                    // Update button content
                    button.innerHTML = buttonContentParts.join(' ');
                });
                

            } else {
                // Boolean variable: Single button update
                let isActive = variable.rawValue === true || variable.rawValue === 1 || variable.rawValue === '1' || variable.rawValue === 'true';
                let currentBoolValue = isActive; // Use actual boolean value for Association-Matching
                
                // Bool-Buttons: Farbe
                // Wenn im Formular die Buttonfarbe transparent gewählt ist, nutze (falls vorhanden)
                // die Farbe aus den Presentation/Associations; ansonsten fallback auf Accent-Color.
                let buttonColor = 'var(--accent-color)';
                let associationIcon = null;
                let associationName = null;
                
                if (variable.isBoolButtonColorTransparent) {
                    const arr = variable.variableAssociations;
                    if (arr && Array.isArray(arr)) {
                        const currentAssociation = arr.find(assoc => assoc.value === currentBoolValue);
                        buttonColor = (currentAssociation && currentAssociation.color) ? currentAssociation.color : 'var(--accent-color)';
                    } else {
                        buttonColor = 'var(--accent-color)';
                    }
                } else {
                    buttonColor = variable.boolButtonColor || 'var(--accent-color)';
                }
                

                
                // Association-Icon und Name für Bool Buttons (nur für Icon/Name)
                const associations = variable.variableAssociations;
                if (associations && Array.isArray(associations)) {
                    const currentAssociation = associations.find(assoc => assoc.value === currentBoolValue);
                    if (currentAssociation) {
                        associationIcon = currentAssociation.icon;
                        associationName = currentAssociation.name;

                    }
                }                
                const opacity = isActive ? '1' : '0.5';

                // Resolve the actual button node; avoid mutating the wrapper
                let targetButton = null;
                if (buttonElement && buttonElement.classList && buttonElement.classList.contains('variable-button')) {
                    targetButton = buttonElement;
                } else if (typeof buttonElement.closest === 'function') {
                    targetButton = buttonElement.closest('.variable-button');
                }
                if (!targetButton && buttonElement && buttonElement.querySelector) {
                    targetButton = buttonElement.querySelector('.variable-button');
                }
                if (!targetButton) {
                    return; // cannot safely update
                }
                // Script-Buttons: Immer aktiv darstellen
                try {
                    if (targetButton.dataset && targetButton.dataset.scriptButton === '1') {
                        isActive = true;
                        currentBoolValue = true;
                    }
                } catch (_) {}

                // Aktualisiere Button-Style
                targetButton.style.backgroundColor = buttonColor;
                // targetButton.style.borderColor = buttonColor; // Border entfernt
                // Do not set inline opacity; rely on classes for consistent full-surface dimming
                // Maintain inactive class for mobile dimming
                if (isActive) {
                    targetButton.classList.remove('inactive');
                } else {
                    targetButton.classList.add('inactive');
                }
                
                // Button-Inhalt zusammenstellen
                let buttonText = '';
                let iconHtml = '';
                
                // Icon-Verarbeitung für Button-Update - Verwende Association-Icon falls vorhanden
                let finalIcon = associationIcon || variable.icon; // Association-Icon hat Priorität
        

        
                if (variable.showIcon && finalIcon && finalIcon !== 'Transparent') {
                    const iconClass = prepareIconForDisplay(finalIcon);
                
                    
                    if (iconClass) {
                        iconHtml = `<i class="${iconClass}" style="margin-right: 6px;"></i>`;
                    }
                }
                let textParts = [];
                if (variable.showIcon && iconHtml) {
                    textParts.push(iconHtml);
                }
                if (variable.showLabel) {
                    // Verwende Variablenname als Label (höchste Priorität), dann Association-Name als Fallback
                    const displayLabel = variable.label || associationName || (isActive ? 'ON' : 'OFF');
                    if (variable.showValue) {
                        // Doppelpunkt nur wenn auch Value angezeigt wird - Label fett
                        textParts.push(`<span style="font-weight: 700;">${displayLabel}:&nbsp;</span>`);
                    } else {
                        // Kein Doppelpunkt wenn nur Label - Label fett
                        textParts.push(`<span style="font-weight: 700;">${displayLabel}</span>`);
                    }
                }
                
                if (variable.showValue) {
                    textParts.push(`<span style="font-weight: normal;">${variable.formattedValue}</span>`);
                }
                
                // Falls keine Checkbox aktiviert ist, zeige Label als Fallback (ohne Doppelpunkt) - fett
                if (!variable.showIcon && !variable.showLabel && !variable.showValue) {
                    textParts.push(`<span style="font-weight: 700;">${variable.label || (isActive ? 'ON' : 'OFF')}</span>`);
                }
                
                buttonText = textParts.join(' ');
                
                // Spezielle Behandlung für nur Icon (ohne Abstand)
                if (variable.showIcon && !variable.showLabel && !variable.showValue && iconHtml) {
                    buttonText = iconHtml.replace('margin-right: 6px;', '');
                }
                
                // Button-Styles: Bool-Button soll IMMER seine buttonWidth verwenden
                let buttonStyleExtras = `width: ${variable.buttonWidth}px; min-width: ${variable.buttonWidth}px;`;
                
                targetButton.innerHTML = buttonText;
            }
        }
        
        // Hilfsfunktion für Progress-Bar-Update

        function clampAndRound(val, min, max, step, digits) {
            let v = Number(val);
            if (!Number.isFinite(v)) v = min;
            if (max < min) { const t = min; min = max; max = t; }
            if (!Number.isFinite(step) || step <= 0) {
                const range = (max - min);
                step = range > 0 ? (range / 100) : 1;
            }
            const ratio = (v - min) / step;
            const rounded = Math.round(ratio);
            v = min + (rounded * step);
            if (v < min) v = min;
            if (v > max) v = max;
            if (Number.isFinite(digits) && digits >= 0) {
                v = Number(v.toFixed(digits));
            }
            return v;
        }

        function updateSliderUI(sc, percent, displayText) {
            const fill = sc.querySelector('.slider-fill');
            const thumb = sc.querySelector('.slider-thumb');
            if (fill) fill.style.width = `${percent}%`;
            if (thumb) thumb.style.left = `${percent}%`;
            const valEl = sc.querySelector('.slider-value');
            const showVal = (() => {
                try {
                    const a = sc.getAttribute('data-show-value');
                    return a === '1' || a === 'true';
                } catch (_) { return true; }
            })();
            if (valEl && typeof displayText !== 'undefined') {
                let suffix = sc.getAttribute('data-suffix') || '';
                if (!suffix) {
                    const cur = valEl.textContent || '';
                    const m = cur.match(/^\s*[-+]?\d+(?:[\.,]\d+)?\s*(.*)$/);
                    suffix = m ? m[1] : '';
                    if (!suffix) {
                        try {
                            const vid = sc.getAttribute('data-variable-id');
                            const fv = window.variableDataCache?.[vid]?.formattedValue;
                            if (typeof fv === 'string') {
                                const mF = fv.match(/^\s*[-+]?\d+(?:[\.,]\d+)?\s*(.*)$/);
                                suffix = mF ? mF[1] : '';
                            }
                        } catch (_) {}
                    }
                    if (suffix) sc.setAttribute('data-suffix', suffix);
                }
                if (typeof displayText === 'number') {
                    const digits = Number(sc.getAttribute('data-digits')) || 0;
                    const numStr = Number(displayText).toFixed(Math.max(0, digits));
                    if (showVal) {
                        valEl.textContent = suffix ? `${numStr} ${suffix}` : numStr;
                    } else {
                        valEl.textContent = '';
                    }
                    try { sc.setAttribute('data-current-value', String(displayText)); } catch (_) {}
                } else {
                    if (showVal) {
                        valEl.textContent = String(displayText);
                    } else {
                        valEl.textContent = '';
                    }
                    const m2 = String(displayText).match(/^\s*[-+]?\d+(?:[\.,]\d+)?\s*(.*)$/);
                    const s2 = m2 ? m2[1] : '';
                    if (s2) sc.setAttribute('data-suffix', s2);
                    try {
                        const mNum = String(displayText).match(/[-+]?\d+(?:[\.,]\d+)?/);
                        if (mNum) sc.setAttribute('data-current-value', String(Number(mNum[0].replace(',', '.'))));
                    } catch (_) {}
                }
            }
        }

        function updateSliderPattern(sc) {
            try {
                const track = sc.querySelector('.slider-track');
                if (!track) return;
                const rect = track.getBoundingClientRect();
                const min = Number(sc.getAttribute('data-min')) || 0;
                const max = Number(sc.getAttribute('data-max')) || 100;
                let step = NaN;
                const stepAttr = sc.getAttribute('data-step');
                if (stepAttr !== null && stepAttr !== '' && !isNaN(Number(stepAttr))) {
                    step = Number(stepAttr);
                } else {
                    // try to get from cache
                    const id = sc.getAttribute('data-variable-id');
                    const vc = (window.variableDataCache && id) ? window.variableDataCache[id] : null;
                    if (vc && Number.isFinite(Number(vc.sliderStep))) {
                        step = Number(vc.sliderStep);
                    }
                }
                const range = Math.max(0.000001, max - min);
                // default: 100 steps if not provided
                const s = (Number.isFinite(step) && step > 0) ? step : (range / 100);
                // compute integer number of intervals using floor to avoid off-by-one
                const stepsCount = Math.max(1, Math.floor((range / s) + 1e-9));
                const px = (rect.width > 0 && stepsCount > 0) ? (rect.width / stepsCount) : 12;
                track.style.setProperty('--slider-step-px', `${px}px`);
                const heightPx = rect.height || parseFloat(getComputedStyle(track).height) || 6;
                let dotPx = Math.max(1, Math.round(heightPx * 0.5));
                // keep clear gap: cap dot size to 40% of tile width
                if (px && isFinite(px)) {
                    dotPx = Math.min(dotPx, Math.max(1, Math.floor(px * 0.4)));
                }
                track.style.setProperty('--slider-dot-size', `${dotPx}px`);
                const dotRadius = Math.max(1, Math.floor(Math.min(dotPx / 2, (isFinite(px) ? px * 0.25 : dotPx / 2))));
                track.style.setProperty('--slider-dot-radius', `${dotRadius}px`);
                try {
                    const vid = sc.getAttribute('data-variable-id');
                    console.debug(`[Slider Pattern] id=${vid} min=${min} max=${max} step=${s} stepsCount=${stepsCount} tile=${px.toFixed ? px.toFixed(2) : px}px dot=${dotPx}px`);
                } catch (_) {}
            } catch (_) {}
        }

        function attachSliderEvents(sc) {
            const track = sc.querySelector('.slider-track');
            const minusBtn = sc.querySelector('.slider-step-btn[data-dir="-1"]');
            const plusBtn = sc.querySelector('.slider-step-btn[data-dir="1"]');
            if (!track) return;
            const id = sc.getAttribute('data-variable-id');
            const min = Number(sc.getAttribute('data-min')) || 0;
            const max = Number(sc.getAttribute('data-max')) || 100;
            const digits = Number(sc.getAttribute('data-digits')) || 0;
            const stepAttr = sc.getAttribute('data-step');
            const step = (stepAttr !== null && stepAttr !== '' && !isNaN(Number(stepAttr))) ? Number(stepAttr) : NaN;

            // initialize dotted spacing according to step size
            updateSliderPattern(sc);
            // extra passes to ensure track width is known (iOS/WebView layout timing)
            try { requestAnimationFrame(() => updateSliderPattern(sc)); } catch (_) {}
            try { setTimeout(() => updateSliderPattern(sc), 0); } catch (_) {}
            try { console.debug(`[Slider Init] id=${id} min=${min} max=${max} stepAttr=${stepAttr || 'n/a'} stepUsed=${Number.isFinite(step) && step > 0 ? step : 'auto'}`); } catch (_) {}
            try {
                if (typeof ResizeObserver !== 'undefined') {
                    const ro = new ResizeObserver(() => updateSliderPattern(sc));
                    ro.observe(track);
                } else {
                    window.addEventListener('resize', () => updateSliderPattern(sc));
                }
            } catch (_) {}

            const getPercentFromClientX = (clientX) => {
                const rect = track.getBoundingClientRect();
                const x = Math.min(Math.max(clientX - rect.left, 0), rect.width);
                return rect.width > 0 ? (x / rect.width) * 100 : 0;
            };
            const percentToValue = (p) => {
                const range = max - min;
                const raw = min + (range * (p / 100));
                return clampAndRound(raw, min, max, step, digits);
            };
            const valueToPercent = (v) => {
                const range = max - min;
                if (range <= 0) return 0;
                return Math.max(0, Math.min(100, ((v - min) / range) * 100));
            };

            let dragging = false;
            let dragValue = null;
            const onPointerMove = (ev) => {
                if (!dragging) return;
                const p = getPercentFromClientX(ev.clientX);
                const v = percentToValue(p);
                dragValue = v;
                const percent = valueToPercent(v);
                updateSliderUI(sc, percent, v);
            };
            const endDrag = () => {
                if (!dragging) return;
                dragging = false;
                try { window.removeEventListener('pointermove', onPointerMove); } catch (_) {}
                try { window.removeEventListener('pointerup', endDrag, true); } catch (_) {}
                if (dragValue !== null && typeof requestAction === 'function') {
                    // Cache und Dataset aktualisieren, damit +/- den neuen Wert als Basis nutzt
                    try {
                        if (window.variableDataCache && window.variableDataCache[id]) {
                            window.variableDataCache[id].rawValue = dragValue;
                        }
                        sc.setAttribute('data-current-value', String(dragValue));
                    } catch (_) {}
                    requestAction(id, dragValue);
                    try { console.debug(`[Slider DragEnd] id=${id} -> ${dragValue}`); } catch (_) {}
                }
                dragValue = null;
            };
            track.addEventListener('pointerdown', (ev) => {
                if (sc.style.pointerEvents === 'none') return;
                dragging = true;
                const p = getPercentFromClientX(ev.clientX);
                const v = percentToValue(p);
                dragValue = v;
                const percent = valueToPercent(v);
                updateSliderUI(sc, percent, v);
                try { track.setPointerCapture(ev.pointerId); } catch (_) {}
                window.addEventListener('pointermove', onPointerMove);
                window.addEventListener('pointerup', endDrag, true);
            });

            const stepClick = (dir) => {
                const vc = window.variableDataCache?.[id];
                let base = NaN;
                // 1) bevorzugt aktueller UI-Wert (Dataset)
                try {
                    const ds = sc.getAttribute('data-current-value');
                    if (ds !== null && ds !== '' && !isNaN(Number(ds))) {
                        base = Number(ds);
                    }
                } catch (_) {}
                // 2) Cache
                if (!Number.isFinite(base)) {
                    base = Number(vc?.rawValue);
                }
                // 3) Fallback: Text
                if (!Number.isFinite(base)) {
                    try {
                        const txt = sc.querySelector('.slider-value')?.textContent || '';
                        const match = txt.match(/[-+]?\d+(?:[\.,]\d+)?/);
                        if (match) base = Number(match[0].replace(',', '.'));
                    } catch (_) {}
                }
                if (!Number.isFinite(base)) base = min;
                const s = Number.isFinite(step) && step > 0 ? step : ((max - min) > 0 ? (max - min) / 100 : 1);
                const next = clampAndRound(base + dir * s, min, max, s, digits);
                // Optimistic UI
                try { if (window.variableDataCache && window.variableDataCache[id]) window.variableDataCache[id].rawValue = next; } catch (_) {}
                try {
                    sc.setAttribute('data-current-value', String(next));
                    updateSliderUI(sc, valueToPercent(next), next);
                } catch (_) {}
                if (typeof requestAction === 'function') {
                    requestAction(id, next);
                }
                try { console.debug(`[Slider +/-] id=${id} base=${base} dir=${dir} step=${s} -> ${next}`); } catch (_) {}
            };
            if (minusBtn) minusBtn.addEventListener('click', (ev) => { ev.preventDefault(); ev.stopPropagation(); stepClick(-1); });
            if (plusBtn) plusBtn.addEventListener('click', (ev) => { ev.preventDefault(); ev.stopPropagation(); stepClick(1); });
        }

        function updateSliderValue(variableId, newValue) {
            const scNodes = document.querySelectorAll(`.slider-container[data-variable-id="${CSS.escape(String(variableId))}"]`);
            if (!scNodes || scNodes.length === 0) return;
            scNodes.forEach((sc) => {
                const min = Number(sc.getAttribute('data-min')) || 0;
                const max = Number(sc.getAttribute('data-max')) || 100;
                const digits = Number(sc.getAttribute('data-digits')) || 0;
                const stepAttr = sc.getAttribute('data-step');
                const step = (stepAttr !== null && stepAttr !== '' && !isNaN(Number(stepAttr))) ? Number(stepAttr) : NaN;
                const v = clampAndRound(Number(newValue), min, max, step, digits);
                const range = max - min;
                const percent = range > 0 ? Math.max(0, Math.min(100, ((v - min) / range) * 100)) : 0;
                let display = v;
                try {
                    const vc = window.variableDataCache?.[variableId];
                    if (vc && typeof vc.formattedValue !== 'undefined' && vc.formattedValue !== null) {
                        display = vc.formattedValue;
                    }
                } catch (_) {}
                updateSliderUI(sc, percent, display);
            });
        }
        function updateProgressDisplay(targetVariableId, variable) {

            
            // Finde alle Progress-Container mit der entsprechenden Variable-ID
            const progressContainers = document.querySelectorAll(`.progress-container[data-variable-id="${targetVariableId}"]`);
            if (!progressContainers || progressContainers.length === 0) {
                return;
            }
            progressContainers.forEach((progressContainer) => {
                const progressBar = progressContainer.querySelector('.progress-bar');
                if (progressBar) {
                    const rawValue = parseFloat(variable.rawValue) || 0;
                    const minValue = parseFloat(variable.progressMin) || 0;
                    const maxValue = parseFloat(variable.progressMax) || 100;
                    let progressPercent = 0;
                    const range = maxValue - minValue;
                    if (range > 0) {
                        progressPercent = ((rawValue - minValue) / range) * 100;
                    }
                    const currentWidth = progressBar.style.width || '0%';
                    const newWidth = progressPercent + '%';
                    if (currentWidth !== newWidth) {
                        progressBar.style.transition = 'none';
                        if (!progressBar.style.width) {
                            progressBar.style.width = currentWidth;
                        }
                        progressBar.offsetWidth;
                        progressBar.style.transition = 'width 3s ease-in-out';
                        progressBar.style.width = newWidth;
                    }
                }
                const progressTextContainer = progressContainer.querySelector('.progress-text');
                if (progressTextContainer) {
                    updateProgressText(progressTextContainer, variable);
                }
                updateTargetMarkerDisplay(progressContainer, variable);
            });
        }
        
        // Hilfsfunktion für Progress-Text-Update
        function updateProgressText(progressTextContainer, variable) {
            
            // Progress-Bar Inhalt basierend auf Konfiguration
            // Transparenz-Stil für inaktive Progress-Bars (Konsistenz mit Initial-Render)
            const inactiveOpacity = variable.progressbarInactive ? 'opacity: 0.5;' : '';
            let progressIconHtml = '';
            if (variable.showIcon && variable.icon && variable.icon !== 'Transparent') {
                const iconClass = prepareIconForDisplay(variable.icon);
                if (iconClass) {
                    progressIconHtml = `<i class="${iconClass} variable-icon" style="color: ${getTextColor(variable)}; ${inactiveOpacity}"></i>`;
                }
            }
            
            let progressTextParts = [];
            
            if (variable.showIcon && progressIconHtml) {
                progressTextParts.push(progressIconHtml);
            }
            
            if (variable.showLabel && variable.label) {
                progressTextParts.push(`<span style="color: ${getTextColor(variable)}; font-weight: 700; ${inactiveOpacity}">${variable.label}:&nbsp;</span>`);
            }
            
            if (variable.showValue) {
                progressTextParts.push(`<span style="color: ${getTextColor(variable)}; ${inactiveOpacity}">${variable.formattedValue}</span>`);
            }
            
            // Falls nichts konfiguriert ist, zeige Wert als Fallback
            if (!variable.showIcon && !variable.showLabel && !variable.showValue) {
                progressTextParts.push(`<span style="color: ${getTextColor(variable)}; ${inactiveOpacity}">${variable.formattedValue}</span>`);
            }
            
            const progressText = progressTextParts.join('');
            
            // Aktualisiere den Haupt-Text
            const mainText = progressTextContainer.querySelector('.progress-main-text');
            if (mainText) {
                mainText.innerHTML = progressText;
            }
            
            // Aktualisiere zweite Variable falls vorhanden
            if (variable.secondVariable) {
                const secondVariableSpan = progressTextContainer.querySelector('.progress-second-variable');
                if (secondVariableSpan) {
                    let secondVariableParts = [];
                    
                    // Icon für zweite Variable
                    if (variable.secondVariable.showIcon && variable.secondVariable.icon && variable.secondVariable.icon !== 'Transparent') {
                        const secondIconClass = prepareIconForDisplay(variable.secondVariable.icon);
                        if (secondIconClass) {
                            secondVariableParts.push(`<i class="${secondIconClass} variable-icon" style="color: ${getTextColor(variable)}; ${inactiveOpacity}"></i>`);
                        }
                    }
                    
                    // Label für zweite Variable
                    if (variable.secondVariable.showLabel && variable.secondVariable.label) {
                        secondVariableParts.push(`<span style="color: ${getTextColor(variable)}; font-weight: 700; ${inactiveOpacity}">${variable.secondVariable.label}:&nbsp;</span>`);
                    }
                    
                    // Wert für zweite Variable (Backend-Wert direkt verwenden)
                    if (variable.secondVariable.showValue) {
                        secondVariableParts.push(`<span style="color: ${getTextColor(variable)}; ${inactiveOpacity}">${variable.secondVariable.formattedValue}</span>`);
                    }
                    
                    // Falls nichts konfiguriert ist, zeige Wert als Fallback
                    if (!variable.secondVariable.showIcon && !variable.secondVariable.showLabel && !variable.secondVariable.showValue) {
                        secondVariableParts.push(`<span style="color: ${getTextColor(variable)}; ${inactiveOpacity}">${variable.secondVariable.formattedValue}</span>`);
                    }

                    secondVariableSpan.innerHTML = secondVariableParts.join('');
                } else if (secondVariableSpan) {
                    secondVariableSpan.innerHTML = '';
                }
            }
        }

        // Update or create the target marker overlay for a progress bar
        function updateTargetMarkerDisplay(progressContainer, variable) {
            try {
                const tgt = variable && variable.progressTarget ? variable.progressTarget : null;
                const hasTarget = !!(tgt && (typeof tgt.rawValue !== 'undefined' || typeof tgt.formattedValue !== 'undefined'));
                if (!hasTarget) {
                    const oldMarker = progressContainer.querySelector('.target-marker');
                    const oldText = progressContainer.querySelector('.target-marker-text');
                    if (oldMarker) oldMarker.remove();
                    if (oldText) oldText.remove();
                    progressContainer.style.removeProperty('--target-percent');
                    return;
                }
                const minValue = parseFloat(variable.progressMin) || 0;
                const maxValue = parseFloat(variable.progressMax) || 100;
                const raw = parseFloat(tgt.rawValue);
                let percent = 0;
                const range = maxValue - minValue;
                if (range > 0 && !isNaN(raw)) {
                    percent = Math.max(0, Math.min(100, ((raw - minValue) / range) * 100));
                }
                progressContainer.style.setProperty('--target-percent', percent + '%');

                let marker = progressContainer.querySelector('.target-marker');
                if (!marker) {
                    marker = document.createElement('div');
                    marker.className = 'target-marker';
                    marker.innerHTML = '<div class="soc-triangle soc-triangle-top"></div><div class="soc-triangle soc-triangle-bottom"></div>';
                    progressContainer.appendChild(marker);
                }
                let textEl = progressContainer.querySelector('.target-marker-text');
                const label = (tgt.label && String(tgt.label).trim() !== '') ? String(tgt.label) : 'Target SOC';
                const displayVal = (typeof tgt.formattedValue !== 'undefined') ? String(tgt.formattedValue) : (isNaN(raw) ? '' : raw.toLocaleString('de-DE', { maximumFractionDigits: 1 }) + ' %');
                if (!textEl) {
                    textEl = document.createElement('span');
                    textEl.className = 'target-marker-text';
                    progressContainer.appendChild(textEl);
                }
                // Synchronisiere Marker-Schriftgröße mit Progress-Text
                try {
                    // 1) CSS-Variable für globale Konsistenz
                    if (typeof variable.fontSize === 'number' && variable.fontSize !== -1) {
                        progressContainer.style.setProperty('--balkenschriftgroesse', variable.fontSize + 'px');
                    } else {
                        // Ermittele tatsächliche Schriftgröße aus dem Progress-Text
                        const ref = progressContainer.querySelector('.progress-text .progress-main-text') || progressContainer.querySelector('.progress-text') || progressContainer;
                        const cs = window.getComputedStyle(ref);
                        if (cs && cs.fontSize) {
                            progressContainer.style.setProperty('--balkenschriftgroesse', cs.fontSize);
                            textEl.style.fontSize = cs.fontSize; // 2) Direkt setzen, falls CSS-Var überschrieben wird
                        }
                    }
                } catch (_) {}
                // Marker-Text basierend auf SecondVariable-Show-Flags zusammenstellen (falls aktiviert)
                const inactiveOpacity = variable.progressbarInactive ? 'opacity: 0.5;' : '';
                let markerHtml = '';
                if (variable.useSecondVariableAsTarget && variable.secondVariable) {
                    const parts = [];
                    // Icon
                    if (variable.secondVariable.showIcon && variable.secondVariable.icon && variable.secondVariable.icon !== 'Transparent') {
                        const iconClass = prepareIconForDisplay(variable.secondVariable.icon);
                        if (iconClass) {
                            parts.push(`<i class="${iconClass} variable-icon" style="color: ${getTextColor(variable)}; ${inactiveOpacity}"></i>`);
                        }
                    }
                    // Label
                    if (variable.secondVariable.showLabel && label) {
                        const colon = variable.secondVariable.showValue ? ':&nbsp;' : '';
                        parts.push(`<span style="color: ${getTextColor(variable)}; font-weight: 700; ${inactiveOpacity}">${label}${colon}</span>`);
                    }
                    // Value
                    if (variable.secondVariable.showValue) {
                        parts.push(`<span style="color: ${getTextColor(variable)}; ${inactiveOpacity}">${displayVal}</span>`);
                    }
                    // Fallback: wenn nichts angezeigt werden soll, dann nur Wert
                    if (parts.length === 0) {
                        parts.push(`<span style="color: ${getTextColor(variable)}; ${inactiveOpacity}">${displayVal}</span>`);
                    }
                    markerHtml = parts.join('');
                } else {
                    // Standard: Label: Wert
                    markerHtml = `<span style="color: ${getTextColor(variable)}; font-weight: 700; ${inactiveOpacity}">${label}:&nbsp;</span>` +
                                 `<span style="color: ${getTextColor(variable)}; ${inactiveOpacity}">${displayVal}</span>`;
                }
                textEl.innerHTML = markerHtml;
                textEl.classList.remove('position-before-bar');
                // Always reset to visible before re-evaluating collision
                textEl.style.visibility = 'visible';
                requestAnimationFrame(() => {
                    try {
                        const containerRect = progressContainer.getBoundingClientRect();
                        const firstRect = textEl.getBoundingClientRect();
                        const overflowsRight = firstRect.right > (containerRect.right - 2);
                        let positionChanged = false;
                        if (overflowsRight) {
                            textEl.classList.add('position-before-bar');
                            const markerX = containerRect.left + (containerRect.width * (percent / 100));
                            const maxLeftWidth = Math.max(0, Math.floor(markerX - containerRect.left - 6));
                            if (maxLeftWidth > 0) {
                                textEl.style.maxWidth = maxLeftWidth + 'px';
                            }
                            positionChanged = true;
                        } else {
                            textEl.style.maxWidth = '';
                        }
                        const doOverlapCheck = () => {
                            const textRect = textEl.getBoundingClientRect();
                            const progressText = progressContainer.querySelector('.progress-text');
                            const mainTextEl = progressContainer.querySelector('.progress-text .progress-main-text');
                            // Wenn Progress-Text unsichtbar ist, nie verstecken
                            if (!progressText) {
                                textEl.style.visibility = 'visible';
                                return;
                            }
                            const ptStyle = window.getComputedStyle(progressText);
                            const ptRect = progressText.getBoundingClientRect();
                            const progressTextHidden = (ptStyle.display === 'none') || (ptRect.width === 0 || ptRect.height === 0);
                            if (progressTextHidden) {
                                textEl.style.visibility = 'visible';
                                return;
                            }
                            if (mainTextEl) {
                                const mainRect = mainTextEl.getBoundingClientRect();
                                const containerRect2 = progressContainer.getBoundingClientRect();
                                const margin = 2; // px tolerance to avoid flicker
                                // Rechte Sichtgrenze: bis zum linken Rand der SecondVariable (falls vorhanden)
                                let rightBound = containerRect2.right;
                                const secondEl = progressContainer.querySelector('.progress-text .progress-second-variable');
                                if (secondEl) {
                                    const secondRect = secondEl.getBoundingClientRect();
                                    rightBound = Math.max(mainRect.left, secondRect.left - 8);
                                }
                                
                                // WICHTIG: Prüfe gegen die tatsächlichen Kind-Elemente (SVG, spans), 
                                // NICHT gegen mainTextEl selbst (der hat flex:1 und geht über volle Breite)
                                const childNodes = Array.from(mainTextEl.querySelectorAll('svg, i, span, b, strong'));
                                let contentLeft = Infinity;
                                let contentRight = -Infinity;
                                
                                childNodes.forEach(node => {
                                    const r = node.getBoundingClientRect();
                                    if (r.width > 0 && r.height > 0) {
                                        contentLeft = Math.min(contentLeft, r.left);
                                        contentRight = Math.max(contentRight, r.right);
                                    }
                                });
                                
                                // Wenn keine sichtbaren Kinder gefunden: kein Text → keine Kollision
                                if (contentLeft === Infinity || contentRight === -Infinity) {
                                    textEl.style.visibility = 'visible';
                                    return;
                                }
                                
                                // Begrenze auf rightBound (für SecondVariable)
                                contentRight = Math.min(contentRight, rightBound);
                                const overlapsHorizontally = !(
                                    (textRect.right <= (contentLeft + margin)) ||
                                    (textRect.left >= (contentRight - margin))
                                );
                                textEl.style.visibility = overlapsHorizontally ? 'hidden' : 'visible';
                            } else {
                                textEl.style.visibility = 'visible';
                            }
                        };
                        // Always one more rAF to let layout settle (after class/size changes)
                        requestAnimationFrame(doOverlapCheck);
                    } catch (_) {}
                });
            } catch (e) {
                // ignore
            }
        }

        function renderStatus(data) {
            // Speichere den letzten Status-Payload für spätere Re-Renders (z.B. bei Asset-/Medien-Updates)
            try { window._lastStatusPayload = data; } catch(_) {}
            const statusContainer = document.getElementById('status-container');
            const root = document.documentElement;
            
            // Neue Option: Statusbereich komplett ausblenden, unabhängig vom Statuswert
            const forceHideStatus = !!data.statusHidden;
            // Zeige Status-Container nur wenn nicht versteckt und Status vorhanden ist
            if (!forceHideStatus && data.status) {
                // Alignment mapping for status
                const alignment = (data.statusAlignment || 'left');
                const justifyMap = alignment === 'center' ? 'center' : (alignment === 'right' ? 'flex-end' : 'flex-start');
                // Use flex container for horizontal alignment
                statusContainer.style.display = 'flex';
                statusContainer.style.justifyContent = justifyMap;
                statusContainer.style.alignItems = 'center';
                statusContainer.style.width = '100%';
                // Bestimme Status-Farbe: verwende --content-color wenn transparent, ansonsten konfigurierte Farbe
                const statusColor = data.isStatusColorTransparent ? 'var(--content-color)' : (data.statusColor || 'var(--content-color)');
                statusContainer.style.setProperty('--status-color', statusColor);
                // Nur font-size setzen wenn nicht -1 - unterscheide zwischen -1 und undefined
                const statusFontSize = data.statusFontSize !== undefined ? data.statusFontSize : 12;
                if (statusFontSize !== -1) {
                    statusContainer.style.fontSize = statusFontSize + 'px';
                } else {
                    statusContainer.style.fontSize = ''; // Reset to default
                }
                
                let statusContent = '';
                
                // Status-Inhalt basierend auf Konfiguration zusammenstellen (wie bei Textvariablen)
                let statusParts = [];
                
                // Icon für Status-Bereich (wenn konfiguriert)
                if (data.statusShowIcon && data.statusIcon && data.statusIcon !== 'Transparent') {
                    const iconClass = prepareIconForDisplay(data.statusIcon);
                    if (iconClass) {
                        statusParts.push(`<i class="${iconClass}" style="color: var(--status-color); margin-right: 4px;"></i>`);
                    }
                }
                
                // Label für Status-Bereich (wenn konfiguriert)
                if (data.statusShowLabel) {
                    const label = data.statusLabel || 'Status'; // Fallback zu "Status" wenn kein Custom Label
                    // Füge ein geschütztes Leerzeichen NUR hinzu, wenn auch ein Wert angezeigt wird
                    const trailingSpace = data.statusShowValue ? '&nbsp;' : '';
                    statusParts.push(`<span class="status-label" style="color: var(--status-color);">${label}:${trailingSpace}</span>`);
                }
                
                // Wert für Status-Bereich (wenn konfiguriert)
                if (data.statusShowValue) {
                    statusParts.push(`<span class="status-value" style="color: var(--status-color);">${data.status}</span>`);
                }
                
                // Fallback: Falls nichts konfiguriert ist, zeige Wert
                if (!data.statusShowIcon && !data.statusShowLabel && !data.statusShowValue) {
                    statusParts.push(`<span class="status-value" style="color: var(--status-color);">${data.status}</span>`);
                }
                
                // Keine zusätzlichen Text-Knoten zwischen Flex-Items erzeugen
                statusContent = statusParts.join('');
                statusContainer.innerHTML = statusContent;
            } else {
                statusContainer.style.display = 'none';
            }
            
            // Gerätebild wird separat im div1 Container angezeigt - IMMER prüfen, auch ohne Status
            if (data.statusBildauswahl) {
                let imageUrl = null;
                
                // DOM-Elemente ZUERST definieren, bevor sie verwendet werden
                const deviceImgContainer = document.getElementById('div1');
                const deviceImg = document.getElementById('image');
                
                // GLOBALE ENTSCHEIDUNG: Soll die gesamte Bildspalte versteckt werden?
                if (window.hideImageColumn) {
                    if (deviceImgContainer) {
                        deviceImgContainer.classList.add('hidden');
                        deviceImgContainer.classList.remove('div1');
                    }
                    return;
                }
                
                // PRO-ASSOZIATION-ENTSCHEIDUNG: Welches Bild/Icon soll für diese Assoziation angezeigt werden?
                if (data.statusBildauswahl.startsWith('symcon_icon_')) {
                    // FontAwesome Icon verwenden
                    const iconName = data.statusBildauswahl.replace('symcon_icon_', '');
                    // WICHTIG: #image darf NICHT Voraussetzung sein (wird im Icon-Modus entfernt)
                    if (iconName && deviceImgContainer) {
                        // Entferne das <img> Element komplett aus dem DOM (nur wenn vorhanden)
                        if (deviceImg && deviceImg.parentNode) {
                            deviceImg.parentNode.removeChild(deviceImg);
                        }
                        
                        // Prüfe ob schon ein Icon-Container existiert
                        let iconContainer = deviceImgContainer.querySelector('.fontawesome-icon-container');
                        if (!iconContainer) {
                            iconContainer = document.createElement('div');
                            iconContainer.className = 'fontawesome-icon-container';
                            deviceImgContainer.appendChild(iconContainer);
                        }
                        
                        // Bereite FontAwesome Icon-Klasse vor (nutze zentrale Logik)
                        const iconClass = prepareIconForDisplay(iconName);
                        
                        // Setze das FontAwesome Icon
                        iconContainer.innerHTML = `<i class="${iconClass}"></i>`;
                        // Farbwahl: individuelle Icon-Farbe oder Fallback auf --accent-color
                        const chosenIconColor = (data.statusIconColor && data.statusIconColor !== '')
                            ? data.statusIconColor
                            : 'var(--accent-color)';
                        iconContainer.style.color = chosenIconColor;
                        // Wandle neu eingefügte <i>-Tags in SVG um (wichtig bei Statuswechsel)
                        try {
                            if (window.FontAwesome && window.FontAwesome.dom && typeof window.FontAwesome.dom.i2svg === 'function') {
                                window.FontAwesome.dom.i2svg({ node: iconContainer, observeMutations: false });
                            }
                        } catch (e) {
                            // still OK, FA wandelt ggf. asynchron per MutationObserver um
                        }
                        // Nur Anzeige steuern, restliche Layout-Eigenschaften kommen aus CSS
                        // Entferne evtl. veraltetes display:none aus vorherigem Modus
                        try { iconContainer.style.removeProperty('display'); } catch (_) {}
                        iconContainer.style.display = 'flex';
                        // WICHTIG: Nicht vollflächig, damit Ausrichtung links/rechts greift
                        iconContainer.style.flex = '0 0 auto';
                        iconContainer.style.width = 'auto';
                        // Margin-basierte Ausrichtung für Icon-Container (wirkt unabhängig von Containerbreite)
                        if (window.currentImageAlignment) {
                            switch (window.currentImageAlignment) {
                                case 'left':
                                    iconContainer.style.margin = '0 auto 0 0';
                                    break;
                                case 'center':
                                    iconContainer.style.margin = '0 auto';
                                    break;
                                case 'right':
                                    iconContainer.style.margin = '0 0 0 auto';
                                    break;
                                default:
                                    iconContainer.style.margin = '0 auto';
                            }
                        }
                        
                        deviceImgContainer.classList.remove('hidden');
                        deviceImgContainer.classList.add('div1');
                        return; // Verlasse die Funktion, da Icon gerendert wurde
                    }
                } else if (data.statusImageUrl) {
                    // Bevorzuge WebHook-URL wenn vorhanden (Media oder Asset)
                    try {
                        if (!deviceImgContainer) return;
                        const oldIcon = deviceImgContainer.querySelector('.fontawesome-icon-container');
                        if (oldIcon) oldIcon.remove();
                        let imgEl = document.getElementById('image');
                        if (!imgEl) {
                            imgEl = document.createElement('img');
                            imgEl.id = 'image';
                            imgEl.alt = 'Device Image';
                            deviceImgContainer.appendChild(imgEl);
                        }
                        imgEl.style.display = 'none';
                        imgEl.style.visibility = 'hidden';
                        try { imgEl.decoding = 'async'; } catch (_) {}
                        try { imgEl.loading = 'eager'; } catch (_) {}
                        let fallbackUrl = null;
                        if (data.statusBildauswahl && typeof data.statusBildauswahl === 'string') {
                            if (window.assets && window.assets[`img_${data.statusBildauswahl}`]) {
                                fallbackUrl = window.assets[`img_${data.statusBildauswahl}`];
                            } else if (data.statusBildauswahl === 'none') {
                                fallbackUrl = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAABBJREFUeNpi+P//PwNAgAEACPwC/tuiTRYAAAAASUVORK5CYII=';
                            }
                        }

                        let triedFallback = false;
                        imgEl.onload = () => {
                            imgEl.style.display = 'block';
                            imgEl.style.visibility = 'visible';
                        };
                        imgEl.onerror = () => {
                            if (!triedFallback && fallbackUrl) {
                                triedFallback = true;
                                imgEl.src = fallbackUrl;
                            } else {
                                imgEl.style.display = 'none';
                                imgEl.style.visibility = 'hidden';
                            }
                        };
                        imgEl.src = data.statusImageUrl;
                        try {
                            if (imgEl.complete && imgEl.naturalWidth > 0) {
                                imgEl.style.display = 'block';
                                imgEl.style.visibility = 'visible';
                            }
                        } catch (_) {}
                        deviceImgContainer.classList.remove('hidden');
                        deviceImgContainer.classList.add('div1');
                    } catch (_) {}
                    return;
                } else if (data.statusBildauswahl.startsWith('img_custom_')) {
                    // Custom Image über Asset-System verwenden
                    imageUrl = window.assets[data.statusBildauswahl];
                } else if (data.statusBildauswahl.startsWith('img_default_')) {
                    // Standard-Bild (Fallback) über Asset-System verwenden
                    imageUrl = window.assets[data.statusBildauswahl];
                } else if (data.statusBildauswahl === 'none') {
                    // Keine Bild für diese Assoziation -> transparentes Platzhalter-Bild verwenden
                    // 1x1 transparentes PNG als Data URI (neue, korrekte Variante)
                    imageUrl = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAABBJREFUeNpi+P//PwNAgAEACPwC/tuiTRYAAAAASUVORK5CYII=';
                } else {
                    // Vorkonfigurierte Bilder verwenden (wm_an, wm_aus, dryer_on, dryer_off, etc.)
                    imageUrl = window.assets[`img_${data.statusBildauswahl}`];
                }
                
                // Für Bilder: Icon-Container entfernen und img-Element anzeigen
                if (deviceImgContainer) {
                    // Existierenden Icon-Container entfernen (mutual exclusive)
                    const oldIcon = deviceImgContainer.querySelector('.fontawesome-icon-container');
                    if (oldIcon) oldIcon.remove();
                    // img-Element wiederherstellen falls es entfernt wurde
                    let deviceImg = document.getElementById('image');
                    if (!deviceImg) {
                        deviceImg = document.createElement('img');
                        deviceImg.id = 'image';
                        deviceImg.alt = 'Device Image';
                        deviceImgContainer.appendChild(deviceImg);
                    }
                    // VOR dem Laden verstecken, Sichtbarkeit erst in onload setzen
                    deviceImg.style.display = 'none';
                    deviceImg.style.visibility = 'hidden';
                    // Event-Handler zurücksetzen
                    deviceImg.onload = null;
                    deviceImg.onerror = null;
                }
                
                if (imageUrl && deviceImgContainer) {
                    let deviceImg = document.getElementById('image');
                    if (deviceImg) {
                        // Nach erfolgreichem Laden erst anzeigen
                        deviceImg.onload = () => {
                            deviceImg.style.display = 'block';
                            deviceImg.style.visibility = 'visible';
                        };
                        // Bei Fehler: transparentes Pixel setzen und verborgen lassen, um Blaue-Kasten zu vermeiden
                        deviceImg.onerror = () => {
                            deviceImg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAABBJREFUeNpi+P//PwNAgAEACPwC/tuiTRYAAAAASUVORK5CYII=';
                            deviceImg.style.display = 'none';
                            deviceImg.style.visibility = 'hidden';
                            // Fehlerfall: Icon sichtbar lassen (kein Hide des Icon-Containers)
                        };
                        deviceImg.src = imageUrl;
                        deviceImgContainer.classList.remove('hidden');
                        deviceImgContainer.classList.add('div1');
                    }

                } else {

                    if (deviceImgContainer) {
                        deviceImgContainer.classList.add('hidden');
                        deviceImgContainer.classList.remove('div1');
                    }
                }
            }
        }

        function renderVariables(variables) {


            const container = document.getElementById('variables-container');
            if (!container) return;
            

            
            // Cache die Variablen-Daten für spätere Re-Rendering
            window.cachedVariables = variables;
            
            // Erstelle Mapping zwischen var_X und Variable-ID
            window.varKeyToIdMapping = {};
            window.variableDataCache = {};
            

            
            // PHASE 1: Berechne maximale Gruppenname-Breite für Alignment
            let maxGroupNameWidth = 0;
            if (window.groupNames) {
                const tempDiv = document.createElement('div');
                tempDiv.style.position = 'absolute';
                tempDiv.style.visibility = 'hidden';
                tempDiv.style.whiteSpace = 'nowrap';
                tempDiv.style.fontWeight = 'bold';
                document.body.appendChild(tempDiv);
                
                // Gruppiere Variablen und finde alle sichtbaren Gruppennamen
                const groupedVariables = variables.reduce((acc, variable) => {
                    if (variable.group && variable.group !== 'keine Gruppe') {
                        if (!acc[variable.group]) acc[variable.group] = [];
                        acc[variable.group].push(variable);
                    }
                    return acc;
                }, {});
                
                // Berechne Breite für jeden sichtbaren Gruppennamen
                Object.keys(groupedVariables).forEach(groupKey => {
                    const groupVariables = groupedVariables[groupKey];
                    
                    // Prüfe ShowGroupName und ShowAbove aus Gruppenkonfiguration
                    let shouldShowGroupName = false;
                    let showAbove = false;
                    const groupMatch = groupKey.match(/Gruppe (\d+)/);
                    if (groupMatch && window.groupNames) {
                        const groupNumber = parseInt(groupMatch[1]);
                        const groupConfig = window.groupNames[groupNumber];
                        shouldShowGroupName = groupConfig && groupConfig.showGroupName === true;
                        showAbove = groupConfig && groupConfig.showAbove === true;
                    }
                    
                    // Nur Gruppennamen berechnen, die LINKS angezeigt werden (nicht showAbove)
                    // Gruppennamen mit showAbove=true brauchen keinen horizontalen Platz
                    if (shouldShowGroupName && !showAbove) {
                        // Bestimme Anzeigenamen
                        let displayGroupName = groupKey;
                        const groupMatch = groupKey.match(/Gruppe (\d+)/);
                        if (groupMatch && window.groupNames) {
                            const groupNumber = parseInt(groupMatch[1]);
                            const groupConfig = window.groupNames[groupNumber];
                            displayGroupName = (groupConfig && groupConfig.name) ? groupConfig.name : groupKey;

                        } else {
                        }
                        
                        // Verwende die gleiche Schriftgröße wie die erste Variable
                        // Nur Fallback wenn fontSize undefined/null ist, nicht bei 0
                        const firstVariableFontSize = groupVariables[0]?.fontSize !== undefined ? groupVariables[0].fontSize : 14;
                        // Nur font-size setzen wenn nicht -1
                        if (firstVariableFontSize !== -1) {
                            tempDiv.style.fontSize = firstVariableFontSize + 'px';
                        }
                        tempDiv.textContent = displayGroupName + ':';
                        
                        let width = tempDiv.offsetWidth;
                        
                        // Prüfe ob diese Gruppe ein Icon hat und füge Icon-Breite hinzu
                        const iconGroupMatch = groupKey.match(/Gruppe (\d+)/);
                        if (iconGroupMatch && window.groupNames) {
                            const groupNumber = parseInt(iconGroupMatch[1]);
                            const groupConfig = window.groupNames[groupNumber];
                            if (groupConfig?.groupIcon && groupConfig.groupIcon !== '') {
                                // Icon-Breite: 16px Icon + 8px margin-right = 24px
                                width += 24;
                            }
                        }
                        
                        maxGroupNameWidth = Math.max(maxGroupNameWidth, width);
                        
                    }
                });
                
                document.body.removeChild(tempDiv);

            }
            
            // Track welche Gruppen bereits gerendert wurden
            const renderedGroups = new Set();
            let content = '';
            
            // Gehe durch Variablen in ORIGINALER REIHENFOLGE
            variables.forEach((variable, index) => {
                // Erstelle Mapping (var_0, var_1, var_2, etc.)
                const varKey = 'var_' + index;
                window.varKeyToIdMapping[varKey] = variable.id;
                window.variableDataCache[variable.id] = variable;
                
                
                // Prüfe ob Variable gruppiert ist - alle Darstellungstypen unterstützen jetzt Gruppen
                if (variable.group && variable.group !== 'keine Gruppe' && variable.group.trim() !== '') {
                    // Nur rendern wenn Gruppe noch nicht gerendert wurde
                    if (!renderedGroups.has(variable.group)) {
                        renderedGroups.add(variable.group);
                        
                        // Sammle alle Variablen dieser Gruppe - alle Darstellungstypen unterstützt
                        const groupVariables = variables.filter(v => 
                            v.group === variable.group && v.group !== 'keine Gruppe' && v.group.trim() !== ''
                        );
                        
                        
                        
                        // Prüfe ShowGroupName aus Gruppenkonfiguration statt aus Variablen
                        let shouldShowGroupName = false;
                        const groupMatch = variable.group.match(/Gruppe (\d+)/);
                        if (groupMatch && window.groupNames) {
                            const groupNumber = parseInt(groupMatch[1]);
                            const groupConfig = window.groupNames[groupNumber];
                            shouldShowGroupName = groupConfig && groupConfig.showGroupName === true;
                        }
                        
                        // Bestimme den Gruppennamen basierend auf der Gruppenbezeichnung
                        // WICHTIG: Mapping erfolgt immer wenn window.groupNames verfügbar ist,
                        // shouldShowGroupName kontrolliert nur die Anzeige!
                        let displayGroupName = variable.group;
                        let showAbove = false;
                        let showLine = false;
                        let stretch = false;
                        if (window.groupNames) {
                            // Extrahiere Gruppennummer aus "Gruppe X" Format
                            const groupMatch = variable.group.match(/Gruppe (\d+)/);
                            if (groupMatch) {
                                const groupNumber = parseInt(groupMatch[1]);
                                const groupConfig = window.groupNames[groupNumber];
                                displayGroupName = (groupConfig && groupConfig.name) ? groupConfig.name : variable.group;
                                showAbove = groupConfig.showAbove || false;
                                showLine = groupConfig.showLine || false;
                                stretch = groupConfig.stretch || false;
                            }

                        } else {
                        }
                        
                        // Bestimme CSS-Klassen für die Gruppe
                        let groupCssClasses = 'variable-group';
                        
                        // Prüfe ob die Gruppe Button-Variablen enthält (Bool, Integer, String) und stretch aktiviert ist
                        const hasButtons = groupVariables.some(v => {
                            return v.displayType === 'button' && (v.variableType === 0 || v.variableType === 1 || v.variableType === 3);
                        });
                        
                        if (stretch && hasButtons) {
                            groupCssClasses += ' stretch-buttons';
                        }
                        
                        // Alternative Darstellung: Gruppenname über der Gruppe
                        if (shouldShowGroupName && showAbove) {
                            // Verwende konfigurierte Schriftgröße aus groupnamesize oder Fallback
                            const groupConfig = window.groupNames?.[parseInt(variable.group.match(/Gruppe (\d+)/)?.[1])];
                            // Nur Fallback wenn fontSize undefined/null ist, nicht bei 0
                            const groupNameFontSize = groupConfig?.fontSize !== undefined ? groupConfig.fontSize : 16;
                            
                            // Nur font-size setzen wenn nicht -1
                            const fontSizeStyle = groupNameFontSize !== -1 ? `font-size: ${groupNameFontSize}px;` : '';
                            
                            // Group Icon vorbereiten
                            let groupIconHtml = '';
                            if (groupConfig?.groupIcon && groupConfig.groupIcon !== '') {
                                const iconClass = prepareIconForDisplay(groupConfig.groupIcon);
                                if (iconClass) {
                                    groupIconHtml = `<i class="${iconClass}" style="margin-right: 8px; color: var(--accent-color);"></i>`;
                                }
                            }
                            
                            content += `
                                <div class="group-name-above" style="font-weight: bold; color: var(--content-color); ${fontSizeStyle} margin-bottom: 0px; margin-top: 10px; text-align: left; opacity: 0.5; display: flex; align-items: center;">
                                    ${groupIconHtml}${displayGroupName}:
                                </div>
                            `;
                            
                        }
                        
                        // Container für die Gruppe - flexDirection je nach showAbove
                        const containerStyle = showAbove && shouldShowGroupName 
                            ? "margin-bottom: var(--element-spacing, 8px); margin-top: var(--element-spacing, 8px); display: flex; flex-direction: column; align-items: stretch;"
                            : "margin-bottom: var(--element-spacing, 8px); margin-top: var(--element-spacing, 8px); display: flex; align-items: flex-start; gap: 16px;";
                        
                        content += `
                            <div class="${groupCssClasses}" style="${containerStyle}">
                        `;
                        
                        // Füge Gruppennamen links hinzu wenn gewünscht (nur wenn NICHT showAbove)
                        if (shouldShowGroupName && !showAbove) {
                            // Verwende die gleiche Schriftgröße wie die erste Variable der Gruppe
                            // Nur Fallback wenn fontSize undefined/null ist, nicht bei 0
                            const firstVariableFontSize = groupVariables[0]?.fontSize !== undefined ? groupVariables[0].fontSize : 14;
                            
                            // Nur font-size setzen wenn nicht -1
                            const labelFontSizeStyle = firstVariableFontSize !== -1 ? `font-size: ${firstVariableFontSize}px;` : '';
                            
                            // Verwende feste Breite für einheitliches Alignment aller Gruppen
                            const groupNameWidth = maxGroupNameWidth > 0 ? maxGroupNameWidth + 'px' : 'auto';
                            
                            // Group Icon vorbereiten
                            const groupConfig = window.groupNames?.[parseInt(variable.group.match(/Gruppe (\d+)/)?.[1])];
                            let groupIconHtml = '';
                            if (groupConfig?.groupIcon && groupConfig.groupIcon !== '') {
                                const iconClass = prepareIconForDisplay(groupConfig.groupIcon);
                                if (iconClass) {
                                    groupIconHtml = `<i class="${iconClass}" style="margin-right: 8px; color: var(--accent-color);"></i>`;
                                }
                            }
                            
                            content += `
                                <div class="group-name-label" style="font-weight: bold; color: var(--content-color); ${labelFontSizeStyle} white-space: nowrap; align-self: center; margin-right: 8px; width: ${groupNameWidth}; display: flex; align-items: center; text-align: left;">
                                    ${groupIconHtml}${displayGroupName}:
                                </div>
                            `;
                            
                        }
                        
                        // Bestimme gruppenweite Ausrichtung: nutze die erste Text/Button-Variable der Gruppe
                        let groupAlign = 'left';
                        // Verwende Text/Button/ODER Image als Quelle für die Gruppenausrichtung
                        const alignSource = groupVariables.find(v => v.displayType === 'text' || v.displayType === 'button' || v.displayType === 'image');
                        if (alignSource && alignSource.alignment) {
                            groupAlign = alignSource.alignment;
                        }
                        const groupJustify = groupAlign === 'center' ? 'center' : (groupAlign === 'right' ? 'flex-end' : 'flex-start');

                        content += `
                                <div class="variable-group-items" style="display: flex; flex-wrap: nowrap; column-gap: 16px; row-gap: calc(var(--element-spacing, 8px)); align-items: center; flex: 1; justify-content: ${groupJustify}; width: 100%;">
                        `;

                        // Gleichmäßiges Wachstum für ALLE Progress/Slider in der Gruppe
                        groupVariables.forEach((groupVar) => {
                            const widthPercent = (groupVar.displayType === 'image' && Number.isFinite(Number(groupVar.imageWidth)))
                                ? Number(groupVar.imageWidth)
                                : null;
                            const isProgressLike = (groupVar.displayType === 'progress' || groupVar.displayType === 'slider');
                            const growStyle = isProgressLike ? 'flex: 1 1 0; min-width: 0;' : '';
                            const widthStyle = (widthPercent !== null)
                                ? ('flex: 0 0 ' + widthPercent + '%; max-width: ' + widthPercent + '%; min-width: ' + widthPercent + '%; box-sizing: border-box;')
                                : '';
                            const itemStyle = (widthPercent !== null || growStyle)
                                ? (' style="' + widthStyle + growStyle + '"')
                                : '';
                            content += `<div class="variable-group-item"${itemStyle}>`;
                            content += renderSingleVariable(groupVar, true); // true = isGrouped
                            content += `</div>`;
                        });
                        
                        content += `
                                </div>
                            </div>
                        `;
                        
                        // Füge Linie unter der Gruppe hinzu wenn showLine aktiviert ist
                        if (showLine) {
                            content += `
                                <div class="group-line"></div>
                            `;
                        }
                    }
                    // Andernfalls überspringen (Gruppe bereits gerendert)
                } else {
                    // Ungrouped variable - sofort rendern
                    content += renderSingleVariable(variable);
                }
            });
            
            
            // Rufe updateImageVisibility() nach dem initialen Rendering auf
            // um sicherzustellen, dass die Bildanzeige korrekt gesetzt wird
            updateImageVisibility();
            
            container.innerHTML = content;
            try {
                const allProgressContainers = container.querySelectorAll('.progress-container');
                allProgressContainers.forEach(pc => {
                    const varId = pc.getAttribute('data-variable-id');
                    const v = window.variableDataCache?.[varId];
                    if (v && v.displayType === 'progress') {
                        updateTargetMarkerDisplay(pc, v);
                    }
                });
                const allSliderContainers = container.querySelectorAll('.slider-container');
                allSliderContainers.forEach(sc => { attachSliderEvents(sc); });
            } catch (_) {}
            
            
            
            // Trigger Progress-Bar-Animation nach DOM-Update
            setTimeout(() => {
                animateProgressBars();
            }, 10); // Kurzer Delay um sicherzustellen dass DOM aktualisiert ist

            // Keine Nachbearbeitung erforderlich – Bilder verwenden direkt WebHook-URLs
        }
        
        // Hilfsfunktion zum Rendern einer einzelnen Variable
        function renderSingleVariable(variable, isGrouped = false) {
            let content = '';
            
            // Bestimme Darstellungstyp für Gruppenlayout
            const isProgressBar = variable.displayType === 'progress' || variable.displayType === 'slider';
            
            // Wrapper-Stil je nach Kontext - Progress-Balken unterstützen jetzt auch Gruppen
            let wrapperStyle;
            // Alignment mapping for text/button
            const alignment = (variable.alignment || 'left');
            const justifyMap = alignment === 'center' ? 'center' : (alignment === 'right' ? 'flex-end' : 'flex-start');
            
            // Nur font-size setzen wenn nicht -1
            const fontSizeStyle = variable.fontSize !== -1 ? `font-size: ${variable.fontSize}px;` : '';
            
            if (isGrouped) {
                if (isProgressBar) {
                    // Progress-Balken in Gruppen: Inline-flex damit sie nebeneinander passen, aber mit voller verfügbarer Breite
                    wrapperStyle = `display: inline-flex; align-items: center; margin: 0; ${fontSizeStyle} color: ${getTextColor(variable)};`;
                } else {
                    // Text/Button-Variablen in Gruppen: eigene Breite, Ausrichtung übernimmt die Gruppe
                    // SPEZIAL: Für Image in Gruppen flex-direction: column, daher align-items für horizontale Ausrichtung
                    const alignForGroupItem = (variable.displayType === 'image') ? `align-items: ${justifyMap};` : '';
                    // Für Bilder in Gruppen: Keine Breite am Wrapper setzen; Breite wird am .variable-group-item gesetzt
                    const noWrapForImage = (variable.displayType === 'image') ? '' : 'white-space: nowrap;';
                    const justifyForGroupItem = (variable.displayType === 'image') ? '' : `justify-content: ${justifyMap};`;
                    const alignSelfForGroupItem = (alignment === 'center') ? 'align-self: center;' : '';
                    wrapperStyle = `display: inline-flex; align-items: center; ${justifyForGroupItem} ${alignForGroupItem} ${alignSelfForGroupItem} margin: 0; ${noWrapForImage} ${fontSizeStyle} color: ${getTextColor(variable)};`;
                }
            } else {
                // Ungrouped: Standard-Layout mit horizontaler Ausrichtung für Text/Button/Image
                if (variable.displayType === 'text' || variable.displayType === 'button' || variable.displayType === 'image' || variable.displayType === 'slider') {
                    wrapperStyle = `display: flex; align-items: center; justify-content: ${justifyMap}; width: 100%; ${fontSizeStyle} color: ${getTextColor(variable)};`;
                } else {
                    wrapperStyle = `${fontSizeStyle} color: ${getTextColor(variable)};`;
                }
            }
                
            // CSS-Klassen für Variable zusammenstellen
            let cssClasses = 'variable-item';
            if (variable.displayType === 'text') {
                cssClasses += ' text-variable';
            } else if (variable.displayType === 'progress') {
                cssClasses += ' progress-variable';
            } else if (variable.displayType === 'slider') {
                cssClasses += ' slider-variable';
            }
            // Füge border-line Klasse hinzu wenn konfiguriert UND NICHT gruppiert
            // Bei gruppierten Variablen zeigt nur die Gruppe die Linie, nicht die einzelnen Variablen
            if (variable.showBorderLine && variable.displayType === 'text' && !isGrouped) {
                cssClasses += ' with-border-line';
            }
                
            // Add data-variable-id to outer wrapper for minimal updates (text/button/image)
            content += `<div class="${cssClasses}" style="${wrapperStyle}" data-variable-id="${variable.id}">`;

                // Wert je nach Darstellungstyp hinzufügen
                if (variable.displayType === 'progress') {
                    // Fortschrittsbalken - nutze Backend-Werte (Backend behandelt bereits Deaktivierung)
                    let rawValue = variable.rawValue;
                    let progressValue = calculateProgressValue(rawValue, variable.progressMin, variable.progressMax);
                    let displayValue = variable.formattedValue;
                    
                    // Verhindere NaN-Werte
                    if (isNaN(progressValue)) {
                        progressValue = 0;
                    }
                    
                    // Berechne Prozentsatz basierend auf Min/Max-Werten
                    const progressPercent = progressValue.toFixed(1) + '%';
                    
                    
                    // Progress-Bar Inhalt basierend auf Konfiguration
                    // Transparenz-Stil für inaktive Progress-Bars
                    const inactiveOpacity = variable.progressbarInactive ? 'opacity: 0.5;' : '';
                    
                    let progressIconHtml = '';
                    if (variable.showIcon && variable.icon && variable.icon !== 'Transparent') {
                        const iconClass = prepareIconForDisplay(variable.icon);
                        if (iconClass) {
                            progressIconHtml = `<i class="${iconClass} variable-icon" style="color: ${getTextColor(variable)}; ${inactiveOpacity}"></i>`;
                        }
                    }
                    
                    let progressTextParts = [];
                    
                    if (variable.showIcon && progressIconHtml) {
                        progressTextParts.push(progressIconHtml);
                    }
                    
                    if (variable.showLabel && variable.label) {
                        progressTextParts.push(`<span style="color: ${getTextColor(variable)}; font-weight: 700; ${inactiveOpacity}">${variable.label}:&nbsp;</span>`);
                    }
                    
                    if (variable.showValue) {
                        progressTextParts.push(`<span style="color: ${getTextColor(variable)}; ${inactiveOpacity}">${displayValue}</span>`);
                    }
                    
                    // Falls nichts konfiguriert ist, zeige Wert als Fallback
                    if (!variable.showIcon && !variable.showLabel && !variable.showValue) {
                        progressTextParts.push(`<span style="color: ${getTextColor(variable)}; ${inactiveOpacity}">${displayValue}</span>`);
                    }
                    
                    const progressText = progressTextParts.join('');
                    
                    // Zweite Variable für rechte Seite vorbereiten
                    let secondVariableText = '';
                    if (variable.secondVariable && !variable.useSecondVariableAsTarget) {
                        let secondVariableParts = [];
                        
                        // Icon für zweite Variable
                        if (variable.secondVariable.showIcon && variable.secondVariable.icon && variable.secondVariable.icon !== 'Transparent') {
                            const secondIconClass = prepareIconForDisplay(variable.secondVariable.icon);
                            if (secondIconClass) {
                                secondVariableParts.push(`<i class="${secondIconClass} variable-icon" style="color: ${getTextColor(variable)}; ${inactiveOpacity}"></i>`);
                            }
                        }
                        
                        // Label für zweite Variable
                        if (variable.secondVariable.showLabel && variable.secondVariable.label) {
                            secondVariableParts.push(`<span style="color: ${getTextColor(variable)}; font-weight: 700; ${inactiveOpacity}">${variable.secondVariable.label}:&nbsp;</span>`);
                        }
                        
                        // Wert für zweite Variable (Backend-Wert direkt verwenden)
                        if (variable.secondVariable.showValue) {
                            secondVariableParts.push(`<span style="color: ${getTextColor(variable)}; ${inactiveOpacity}">${variable.secondVariable.formattedValue}</span>`);
                        }
                        
                        // Falls nichts konfiguriert ist, zeige Wert als Fallback
                        if (!variable.secondVariable.showIcon && !variable.secondVariable.showLabel && !variable.secondVariable.showValue) {
                            secondVariableParts.push(`<span style="color: ${getTextColor(variable)}; ${inactiveOpacity}">${variable.secondVariable.formattedValue}</span>`);
                        }
                        
                        if (secondVariableParts.length > 0) {
                            secondVariableText = `<span class="progress-second-variable">${secondVariableParts.join('')}</span>`;
                        }
                    }
                    
                  
                    // Berechne individuelles Padding basierend auf Variable-Textgröße
                    const individualPadding = Math.max(4, Math.round(variable.fontSize / 1)); // Minimum 4px
                    
                    // ANIMATION FIX: Verwende ALTE Breite für DOM, nicht neue!
                    let widthForDOM = progressValue; // Default: neuer Wert
                    
                    // Prüfe ob bereits eine alte Breite gespeichert ist
                    if (window.previousProgressWidths && window.previousProgressWidths[variable.id] !== undefined) {
                        const oldWidth = window.previousProgressWidths[variable.id];
                        
                        // ANIMATION VOR UPDATE: Prüfe ob Animation nötig ist
                        if (Math.abs(progressValue - oldWidth) > 0.1) {
                            // Mark for animation - no DOM update yet!
                            needsAnimation = true;
                            animationTargetWidth = progressValue;
                            widthForDOM = oldWidth; // Keep old width in DOM to enable animation
                            
                            // Store animation info for later triggering
                            if (!window.pendingProgressAnimations) {
                                window.pendingProgressAnimations = new Map();
                            }
                            window.pendingProgressAnimations.set(variable.id, {
                                from: oldWidth,
                                to: progressValue
                            });
                        } else {
                            // Keine Animation nötig - DOM kann direkt aktualisiert werden
                            widthForDOM = progressValue;
                        }
                        
                        // Erste Render: Speichere den Wert direkt
                        if (!window.previousProgressWidths) {
                            window.previousProgressWidths = {};
                        }
                        window.previousProgressWidths[variable.id] = progressValue;
                    } else {
                        // Erste Render: Speichere den Wert direkt
                        if (!window.previousProgressWidths) {
                            window.previousProgressWidths = {};
                        }
                        window.previousProgressWidths[variable.id] = progressValue;
                    }
                    
                    // Target marker percent based on optional progressTarget
                    let targetPercent = null;
                    if (variable.progressTarget && (typeof variable.progressTarget.rawValue !== 'undefined')) {
                        const tRaw = parseFloat(variable.progressTarget.rawValue);
                        const tMin = parseFloat(variable.progressMin) || 0;
                        const tMax = parseFloat(variable.progressMax) || 100;
                        const tRange = tMax - tMin;
                        if (tRange > 0 && !isNaN(tRaw)) {
                            targetPercent = Math.max(0, Math.min(100, ((tRaw - tMin) / tRange) * 100));
                        } else {
                            targetPercent = 0;
                        }
                    }

                    // Build optional target marker HTML
                    let targetMarkerHtml = '';
                    if (targetPercent !== null) {
                        const inactiveOpacity = variable.progressbarInactive ? 'opacity: 0.5;' : '';
                        const posClass = (targetPercent <= 50) ? 'position-before-bar' : '';
                        const tgtLabel = (variable.progressTarget.label && String(variable.progressTarget.label).trim() !== '') ? String(variable.progressTarget.label) : 'Target SOC';
                        const tgtText = (typeof variable.progressTarget.formattedValue !== 'undefined') ? String(variable.progressTarget.formattedValue) : '';
                        let markerTextParts = [];
                        if (variable.useSecondVariableAsTarget && variable.secondVariable) {
                            // Icon
                            if (variable.secondVariable.showIcon && variable.secondVariable.icon && variable.secondVariable.icon !== 'Transparent') {
                                const secondIconClass = prepareIconForDisplay(variable.secondVariable.icon);
                                if (secondIconClass) {
                                    markerTextParts.push(`<i class="${secondIconClass} variable-icon" style="color: ${getTextColor(variable)}; ${inactiveOpacity}"></i>`);
                                }
                            }
                            // Label
                            if (variable.secondVariable.showLabel && tgtLabel) {
                                const colon = variable.secondVariable.showValue ? ':&nbsp;' : '';
                                markerTextParts.push(`<span style="color: ${getTextColor(variable)}; font-weight: 700; ${inactiveOpacity}">${tgtLabel}${colon}</span>`);
                            }
                            // Value
                            if (variable.secondVariable.showValue) {
                                markerTextParts.push(`<span style="color: ${getTextColor(variable)}; ${inactiveOpacity}">${tgtText}</span>`);
                            }
                            if (markerTextParts.length === 0) {
                                // Fallback: nur Wert
                                markerTextParts.push(`<span style="color: ${getTextColor(variable)}; ${inactiveOpacity}">${tgtText}</span>`);
                            }
                        } else {
                            // Fallback: Standarddarstellung Label: Value
                            markerTextParts.push(`<span style="color: ${getTextColor(variable)}; font-weight: 700; ${inactiveOpacity}">${tgtLabel}:&nbsp;</span>`);
                            markerTextParts.push(`<span style="color: ${getTextColor(variable)}; ${inactiveOpacity}">${tgtText}</span>`);
                        }
                        const markerTextHtml = markerTextParts.join('');
                        targetMarkerHtml = `
                            <div class="target-marker">
                                <div class="soc-triangle soc-triangle-top"></div>
                                <div class="soc-triangle soc-triangle-bottom"></div>
                            </div>
                            <span class="target-marker-text ${posClass}">${markerTextHtml}</span>
                        `;
                    }

                    const targetPercentStyle = (targetPercent !== null) ? ` --target-percent: ${targetPercent}%;` : '';
                    // Sync marker font-size with variable font-size via CSS var
                    const markerFontSizeVar = (typeof variable.fontSize === 'number' && variable.fontSize !== -1) ? ` --balkenschriftgroesse: ${variable.fontSize}px;` : '';
                    const normalizeColorP = (c) => {
                        if (c === -1 || c === '-1' || c === null || c === undefined) return 'var(--accent-color)';
                        if (typeof c !== 'string') return c;
                        const s = c.trim().toLowerCase();
                        // Symcon sentinel for -1 as 64-bit hex
                        if (s === '#ffffffffffffffff' || s === '0xffffffffffffffff' || s === 'ffffffffffffffff') return 'var(--accent-color)';
                        if (!s || s === 'transparent' || s === '#0000' || s === '#00000000') return 'var(--accent-color)';
                        if (/^rgba\s*\(\s*\d+\s*,\s*\d+\s*,\s*\d+\s*,\s*0\s*\)$/.test(s)) return 'var(--accent-color)';
                        if (/^rgb\s*\(\s*\d+\s+\d+\s+\d+\s*\/\s*0\s*\)$/.test(s)) return 'var(--accent-color)';
                        if (/^hsla\s*\(.*?,\s*0\s*\)$/.test(s)) return 'var(--accent-color)';
                        if (/^#[0-9a-f]{8}$/.test(s) && s.endsWith('00')) return 'var(--accent-color)';
                        return c;
                    };
                    const color1p = normalizeColorP(variable.progressColor1);
                    const color2p = normalizeColorP(variable.progressColor2);

                    content += `
                        <div class="variable-progress">
                            <div class="progress-container" data-variable-id="${variable.id}" data-new-width="${progressValue}" style="--progress-color1: ${color1p}; --progress-color2: ${color2p}; --progress-bar-text-padding: ${individualPadding}px;${targetPercentStyle}${markerFontSizeVar}">
                                <div class="progress-bar" style="width: ${widthForDOM}%;"></div>
                                ${targetMarkerHtml}
                                <div class="progress-text">
                                    <span class="progress-main-text">${progressText}</span>
                                    ${secondVariableText}
                                </div>
                            </div>
                        </div>
                    `;
                } else if (variable.displayType === 'slider') {
                    const inactiveStyle = variable.progressbarInactive ? 'opacity: 0.5; pointer-events: none;' : '';
                    const min = parseFloat(variable.progressMin) || 0;
                    const max = parseFloat(variable.progressMax) || 100;
                    const range = Math.max(0.000001, max - min);
                    const cur = parseFloat(variable.rawValue) || 0;
                    const percent = Math.max(0, Math.min(100, ((cur - min) / range) * 100));
                    const step = Number.isFinite(Number(variable.sliderStep)) ? Number(variable.sliderStep) : null;
                    const digits = Number.isFinite(Number(variable.sliderDigits)) ? Number(variable.sliderDigits) : 0;
                    const iconHtml = (variable.showIcon && variable.icon && variable.icon !== 'Transparent') ? (()=>{ const c = prepareIconForDisplay(variable.icon); return c ? `<i class="${c} variable-icon" style="color: var(--accent-color);"></i>` : ''; })() : '';
                    const labelHtml = (variable.showLabel && variable.label) ? `<span class="variable-label" style="font-weight: 700;">${variable.label}${variable.showValue ? ':&nbsp;' : ''}</span>` : '';
                    const valueHtml = (variable.showValue && typeof variable.formattedValue !== 'undefined') ? `<span class="slider-value">${variable.formattedValue}</span>` : `<span class="slider-value"></span>`;
                    const individualPadding = 0;
                    const normalizeColorS = (c) => {
                        if (c === -1 || c === '-1' || c === null || c === undefined) return 'var(--accent-color)';
                        if (typeof c !== 'string') return c;
                        const s = c.trim().toLowerCase();
                        // Symcon sentinel for -1 as 64-bit hex
                        if (s === '#ffffffffffffffff' || s === '0xffffffffffffffff' || s === 'ffffffffffffffff') return 'var(--accent-color)';
                        if (!s || s === 'transparent' || s === '#0000' || s === '#00000000') return 'var(--accent-color)';
                        if (/^rgba\s*\(\s*\d+\s*,\s*\d+\s*,\s*\d+\s*,\s*0\s*\)$/.test(s)) return 'var(--accent-color)';
                        if (/^rgb\s*\(\s*\d+\s+\d+\s+\d+\s*\/\s*0\s*\)$/.test(s)) return 'var(--accent-color)';
                        if (/^hsla\s*\(.*?,\s*0\s*\)$/.test(s)) return 'var(--accent-color)';
                        if (/^#[0-9a-f]{8}$/.test(s) && s.endsWith('00')) return 'var(--accent-color)';
                        return c;
                    };
                    const color1s = normalizeColorS(variable.progressColor1);
                    const color2s = normalizeColorS(variable.progressColor2);
                    try { console.log(`[Slider Colors] id=${variable.id}`, { raw1: variable.progressColor1, raw2: variable.progressColor2, color1: color1s, color2: color2s, dots: color1s }); } catch (_) {}

                    const suffixGuess = (() => {
                        if (typeof variable.formattedValue === 'string') {
                            const m = variable.formattedValue.match(/^\s*[-+]?\d+(?:[\.,]\d+)?\s*(.*)$/);
                            return m ? m[1] : '';
                        }
                        return '';
                    })();
                    const signChars = (min < 0 || max < 0) ? 1 : 0;
                    const maxAbs = Math.max(Math.abs(min), Math.abs(max));
                    let intDigits = 1;
                    if (Number.isFinite(maxAbs) && maxAbs >= 1) {
                        intDigits = Math.floor(Math.log10(maxAbs)) + 1;
                    }
                    const decimalChars = (digits > 0) ? (1 + digits) : 0; // Komma/Punkt + Nachkommastellen
                    const valueWidthCh = Math.max(4, signChars + intDigits + decimalChars + (suffixGuess ? suffixGuess.length : 0));
                    const suffixAttr = String(suffixGuess).replace(/"/g, '&quot;');

                    content += `
                        <div class="slider-container" data-variable-id="${variable.id}" data-min="${min}" data-max="${max}" data-step="${step !== null ? step : ''}" data-digits="${digits}" data-suffix="${suffixAttr}" data-show-value="${variable.showValue ? '1' : '0'}" style="--progress-color1: ${color1s}; --progress-color2: ${color2s}; --slider-dots-color: ${color1s}; --slider-value-width: ${valueWidthCh}ch; ${inactiveStyle}">
                            ${iconHtml}${labelHtml}
                            <button class="slider-step-btn" data-dir="-1">−</button>
                            <div class="slider-track" style="--progress-color1: ${color1s}; --progress-color2: ${color2s}; --slider-dots-color: ${color1s}; --progress-bar-text-padding: ${individualPadding}px;">
                                <div class="slider-fill" style="width: ${percent}%;"></div>
                                <div class="slider-thumb" style="left: ${percent}%;"></div>
                            </div>
                            <button class="slider-step-btn" data-dir="1">+</button>
                            ${valueHtml}
                        </div>
                    `;
                } else if (variable.displayType === 'image') {
                    // Rendering: Symcon Medienobjekt als Data-URI mit Breite/Radius und optional Icon/Label/Value
                    let parts = [];
                    // Image width is now percentage (1-100). Default 40% when not set.
                    const imgWidth = Number.isFinite(Number(variable.imageWidth)) ? Number(variable.imageWidth) : 40;
                    const imgRadius = Number.isFinite(variable.imageBorderRadius) ? variable.imageBorderRadius : 6;
                    const imgWidthForDOM = imgWidth; // Respektiere konfigurierte Breite auch in Gruppen
                    const imgFlex = '0 0 auto'; // Keine automatische Größenanpassung
                    
                    // Text-Align für gruppierte Bilder basierend auf alignment
                    const textAlignStyle = isGrouped ? `text-align: ${alignment};` : '';

                    // Icon optional anzeigen
                    if (variable.showIcon && variable.icon && variable.icon !== 'Transparent') {
                        const iconClass = prepareIconForDisplay(variable.icon);
                        if (iconClass) {
                            parts.push(`<i class="${iconClass} variable-icon" style="color: ${getTextColor(variable)};"></i>`);
                        }
                    }

                    // Label optional anzeigen (mit Doppelpunkt, wenn Value ebenfalls angezeigt wird)
                    if (variable.showLabel && variable.label) {
                        const labelText = variable.showValue ? `${variable.label}:&nbsp;` : variable.label;
                        parts.push(`<span class="variable-label" style="color: ${getTextColor(variable)}; font-weight: 700; ${textAlignStyle}">${labelText}</span>`);
                    }

                    const imgAlt = variable.label ? String(variable.label).replace(/"/g, '&quot;') : 'Image';
                    const imgWidthCss = isGrouped ? '100%' : `${imgWidthForDOM}%`;
                    const primarySrc = (typeof variable.imageUrl === 'string') ? variable.imageUrl : '';
                    parts.push(`<img class="variable-inline-image" ${primarySrc ? `src=\"${primarySrc}\"` : ''} alt="${imgAlt}" style="display: none; width: ${imgWidthCss}; height: auto; border-radius: ${imgRadius}px; flex: ${imgFlex};" onload="this.style.display='';" onerror="this.style.display='none';">`);

                    // Value optional anzeigen
                    if (variable.showValue && typeof variable.formattedValue !== 'undefined') {
                        parts.push(`<span class="variable-value variable-text" style="flex: 0 0 auto; ${textAlignStyle}">${variable.formattedValue}</span>`);
                    }

                    content += parts.join(' ');
                } else if (variable.displayType === 'button') {
                    // Button für Bool-Variablen (VARIABLETYPE_BOOLEAN = 0) und Integer-Variablen (VARIABLETYPE_INTEGER = 1)
                    if (variable.variableType === 0) {
                        // Boolean-Variable: Einzelner Button
                        
                        // Erweiterte Bool-Wert-Erkennung
                        const isScriptButton = (typeof variable.id === 'string' && variable.id.indexOf('script_') === 0);
                        const spinActive = (isScriptButton && window._scriptButtonSpinUntil && window._scriptButtonSpinUntil[variable.id] && Date.now() < window._scriptButtonSpinUntil[variable.id]);
                        // Script-Buttons sollen optisch immer aktiv sein
                        const isActive = isScriptButton ? true : (variable.rawValue === true || variable.rawValue === 1 || variable.rawValue === '1' || variable.rawValue === 'true');
                        // Verwende den tatsächlichen Boolean-Wert für Association-Matching (nicht Integer-Konvertierung!)
                        const currentBoolValue = variable.rawValue; // Direkt verwenden, da Associations auch Boolean-Werte haben
                        
                        
                        // Bool-Buttons: Farbe (initial rendering)
                        // Transparent im Formular => versuche Presentation-Farbe; sonst Accent-Color
                        let buttonColor = 'var(--accent-color)';
                        let associationIcon = null;
                        let associationName = null;
                        
                        if (variable.isBoolButtonColorTransparent) {
                            const arr = variable.variableAssociations;
                            if (arr && Array.isArray(arr)) {
                                const currentAssociation = arr.find(assoc => assoc.value === currentBoolValue);
                                buttonColor = (currentAssociation && currentAssociation.color) ? currentAssociation.color : 'var(--accent-color)';
                            } else {
                                buttonColor = 'var(--accent-color)';
                            }
                        } else {
                            buttonColor = variable.boolButtonColor || 'var(--accent-color)';
                        }
                        

                        
                        // Association-Icon und Name für Bool Buttons (nur für Icon/Name, nicht für Farbe)
                        const associations = variable.variableAssociations;
                        if (associations && Array.isArray(associations)) {
                            const currentAssociation = associations.find(assoc => assoc.value === currentBoolValue);
                            if (currentAssociation) {
                                associationIcon = currentAssociation.icon;
                                associationName = currentAssociation.name;

                            }
                        }                
                        const opacity = isActive ? '1' : '0.5'; // Script-Buttons gelten immer als aktiv → oben isActive=true
                        const buttonWidth = variable.buttonWidth || 120;
                        
                        // Prüfe ob die aktuelle Gruppe im stretch-Modus ist
                        let isGroupStretched = false;
                        if (isGrouped && variable.group && window.groupNames) {
                            const groupMatch = variable.group.match(/Gruppe (\d+)/);
                            if (groupMatch) {
                                const groupNumber = parseInt(groupMatch[1]);
                                const groupConfig = window.groupNames[groupNumber];
                                if (groupConfig && groupConfig.stretch) {
                                    isGroupStretched = true;
                                }
                            }
                        }
                        
                        let buttonText = '';
                        let iconHtml = '';
                        
                        // Icon-Verarbeitung für Button - Verwende Association-Icon falls vorhanden
                        let finalIcon = associationIcon || variable.icon; // Association-Icon hat Priorität
                        if (variable.showIcon && finalIcon && finalIcon !== 'Transparent') {
                            const baseClass = prepareIconForDisplay(finalIcon);
                            if (baseClass) {
                                const iconClass = spinActive ? `${baseClass} fa-spin` : baseClass; // nur fa-spin hinzufügen
                                iconHtml = `<i class="${iconClass}" style="margin-right: 6px;"></i>`;
                            }
                        } else if (spinActive) {
                            // Kein Icon konfiguriert, aber Spin aktiv → temporären Spinner darstellen
                            const spinBase = prepareIconForDisplay('rotate') || 'fa-fw fa-kit fak fa-rotate';
                            iconHtml = `<i class="${spinBase} fa-spin" style="margin-right: 6px;"></i>`;
                        }
                        let textParts = [];
                        
                        if (variable.showIcon && iconHtml) {
                            textParts.push(iconHtml);
                        }
                        
                        if (variable.showLabel) {
                            // Verwende Variablenname als Label (höchste Priorität), dann Association-Name als Fallback
                            const displayLabel = variable.label || associationName || (isActive ? 'ON' : 'OFF');
                            if (variable.showValue) {
                                // Doppelpunkt nur wenn auch Value angezeigt wird - Label fett
                                textParts.push(`<span style="font-weight: 700;">${displayLabel}:&nbsp;</span>`);
                            } else {
                                // Kein Doppelpunkt wenn nur Label - Label fett
                                textParts.push(`<span style="font-weight: 700;">${displayLabel}</span>`);
                            }
                        }
                        
                        if (variable.showValue) {
                            textParts.push(`<span style="font-weight: normal;">${variable.formattedValue}</span>`);
                        }
                        
                        // Falls keine Checkbox aktiviert ist, zeige Label als Fallback (ohne Doppelpunkt) - fett
                        if (!variable.showIcon && !variable.showLabel && !variable.showValue) {
                            textParts.push(`<span style="font-weight: 700;">${variable.label || (isActive ? 'ON' : 'OFF')}</span>`);
                        }
                        
                        buttonText = textParts.join(' ');
                        
                        // Spezielle Behandlung für nur Icon (ohne Abstand)
                        if (variable.showIcon && !variable.showLabel && !variable.showValue && iconHtml) {
                            buttonText = iconHtml.replace('margin-right: 6px;', '');
                        }
                        
                        // Button-Styles: Bool-Button soll IMMER seine buttonWidth verwenden
                        let buttonStyleExtras = `width: ${buttonWidth}px; min-width: ${buttonWidth}px;`;
                        
                        // Für ungruppierte Buttons: horizontale Ausrichtung des Containers entsprechend Einstellung
                        const buttonContainerJustify = (!isGrouped) ? `justify-content: ${justifyMap};` : '';
                        content += `
                            <div class="variable-button-container" style="${buttonContainerJustify}">
                                <div class="variable-button ${isActive ? '' : 'inactive'}" role="button" tabindex="0"
                                        onclick="handleButtonClick(this, '${variable.id}', 1);" 
                                        data-variable-id="${variable.id}"
                                        data-script-button="${isScriptButton ? '1' : '0'}"
                                        data-open-object-id="${variable.openObjectId || 0}"
                                        style="background-color: ${buttonColor} !important; color: ${getTextColor(variable)} !important; ${buttonStyleExtras}">
                                    ${buttonText}
                                </div>
                            </div>
                        `;
                        
                    } else if ((variable.variableType === 1 || variable.variableType === 3) && (variable.variableAssociations || variable.integerAssociations)) {
                        // Integer/String-Variable: Multi-Button für jede Association
                        const associations = variable.variableAssociations || variable.integerAssociations;
                        const variableTypeLabel = variable.variableType === 1 ? 'Integer' : 'String';
                        
                        // ButtonWidth aus Variablenkonfiguration verwenden (wie bei Boolean-Buttons)
                        const buttonWidth = variable.buttonWidth || 80; // Etwas schmaler für Multi-Buttons
                        
                        // Prüfe ob die aktuelle Gruppe im stretch-Modus ist (dann keine feste Breite setzen)
                        let isGroupStretched = false;
                        if (isGrouped && variable.group && window.groupNames) {
                            const groupMatch = variable.group.match(/Gruppe (\d+)/);
                            if (groupMatch) {
                                const groupNumber = parseInt(groupMatch[1]);
                                const groupConfig = window.groupNames[groupNumber];
                                if (groupConfig && groupConfig.stretch) {
                                    isGroupStretched = true;
                                }
                            }
                        }
                        
                        let buttonsHtml = '';
                        const currentValue = variable.variableType === 1 ? parseInt(variable.rawValue) : variable.rawValue;
                        
                        associations.forEach((association, index) => {
                            const isActive = currentValue === association.value;
                            const buttonColor = association.color || 'var(--accent-color)';
                            const opacity = isActive ? '1' : '0.5';
                            
                            // Button-Gruppierung: Bestimme CSS-Klasse basierend auf Position
                            let positionClass = '';
                            const totalButtons = associations.length;
                            
                            if (totalButtons === 1) {
                                positionClass = 'single-button'; // Nur ein Button: alle Ecken rund
                            } else if (index === 0) {
                                positionClass = 'first-button'; // Erster Button: nur links rund
                            } else if (index === totalButtons - 1) {
                                positionClass = 'last-button'; // Letzter Button: nur rechts rund
                            } else {
                                positionClass = 'middle-button'; // Mittlere Buttons: keine runden Ecken
                            }
                            
                            // Button-Text basierend auf Display-Konfiguration generieren
                            let buttonContentParts = [];
                            
                            // Icon hinzufügen falls konfiguriert und vorhanden
                            if (variable.showIcon) {
                                let iconToUse = association.icon;
                                if (!iconToUse || iconToUse === 'Transparent' || iconToUse === null) {
                                    iconToUse = variable.icon; // Fallback auf Standard-Icon der Variable
                                }
                                
                                if (iconToUse && iconToUse !== 'Transparent') {
                                    const iconClass = prepareIconForDisplay(iconToUse);
                                    if (iconClass) {
                                        buttonContentParts.push(`<i class="${iconClass}" style="margin-right: 4px;"></i>`);
                                    }
                                }
                            }
                            
                            // Label hinzufügen falls konfiguriert
                            if (variable.showLabel && association.name) {
                                if (variable.showValue) {
                                    // Label mit Doppelpunkt wenn auch Value gezeigt wird
                                    buttonContentParts.push(`<span style="font-weight: 700;">${association.name}:&nbsp;</span>`);
                                } else {
                                    // Nur Label ohne Doppelpunkt
                                    buttonContentParts.push(`<span style="font-weight: 700;">${association.name}</span>`);
                                }
                            }
                            
                            // Value hinzufügen falls konfiguriert
                            if (variable.showValue) {
                                // Bei aktiven Buttons: aktueller Wert, bei inaktiven: Association-Name als Value
                                const displayValue = isActive ? variable.formattedValue : association.name;
                                buttonContentParts.push(`<span style="font-weight: normal;">${displayValue}</span>`);
                            }
                            
                            // Falls keine Checkbox aktiviert ist, zeige Association-Name als Fallback
                            if (!variable.showIcon && !variable.showLabel && !variable.showValue) {
                                buttonContentParts.push(`<span>${association.name || 'Wert ' + association.value}</span>`);
                            }
                            
                            const buttonText = buttonContentParts.join(' ');
                            
                            buttonsHtml += `
                                <div class="variable-multi-button ${positionClass} ${isActive ? 'active' : ''} ${isActive ? '' : 'inactive'}" role="button" tabindex="0"
                                        onclick="handleButtonClick(this, '${variable.id}', ${variable.variableType === 1 ? association.value : "'" + association.value + "'"});" 
                                        data-variable-id="${variable.id}"
                                        data-association-value="${association.value}"
                                        style="background-color: ${buttonColor} !important; color: ${getTextColor(variable)} !important; ${isGroupStretched ? '' : `width: ${buttonWidth}px; min-width: ${buttonWidth}px;`}">
                                    ${buttonText}
                                </div>`;
                        });
                        
                        // Für ungruppierte Multi-Buttons: horizontale Ausrichtung des Containers entsprechend Einstellung
                        const multiButtonContainerJustify = (!isGrouped) ? `display: flex; justify-content: ${justifyMap}; width: 100%;` : '';
                        content += `
                            <div class="variable-button-container" style="${multiButtonContainerJustify}">
                                <div class="variable-multi-button-container" style="${multiButtonContainerJustify}">
                                    ${buttonsHtml}
                                </div>
                            </div>
                        `;
                        
                    } else if (variable.variableType === 3 && variable.stringAssociations && variable.stringAssociations.length > 0) {
                        // String-Variable: Multi-Button für jede Association
                        
                        // ButtonWidth aus Variablenkonfiguration verwenden (wie bei Boolean-Buttons)
                        const buttonWidth = variable.buttonWidth || 80; // Etwas schmaler für Multi-Buttons
                        
                        let buttonsHtml = '';
                        const currentValue = String(variable.rawValue); // String-Wert als String behandeln
                        
                        variable.stringAssociations.forEach((association, index) => {
                            const isActive = currentValue === String(association.value);
                            const buttonColor = association.color || 'var(--accent-color)';
                            const opacity = isActive ? '1' : '0.5';
                            
                            // Button-Gruppierung: Bestimme CSS-Klasse basierend auf Position
                            let positionClass = '';
                            const totalButtons = variable.stringAssociations.length;
                            
                            if (totalButtons === 1) {
                                positionClass = 'single-button'; // Nur ein Button: alle Ecken rund
                            } else if (index === 0) {
                                positionClass = 'first-button'; // Erster Button: nur links rund
                            } else if (index === totalButtons - 1) {
                                positionClass = 'last-button'; // Letzter Button: nur rechts rund
                            } else {
                                positionClass = 'middle-button'; // Mittlere Buttons: keine runden Ecken
                            }
                            
                            // Button-Text basierend auf Association-Name
                            let buttonText = association.name || String(association.value);
                            
                            // Icon hinzufügen falls vorhanden, mit Fallback auf Standard-Icon
                            let iconToUse = association.icon;
                            if (!iconToUse || iconToUse === 'Transparent' || iconToUse === null) {
                                iconToUse = variable.icon; // Fallback auf Standard-Icon der Variable
                            }
                            
                            if (iconToUse && iconToUse !== 'Transparent') {
                                const iconClass = prepareIconForDisplay(iconToUse);
                                if (iconClass) {
                                    buttonText = `<i class="${iconClass}" style="margin-right: 4px;"></i>${buttonText}`;
                                }
                            }
                            
                            buttonsHtml += `
                                <div class="variable-multi-button ${positionClass} ${isActive ? 'active' : ''} ${isActive ? '' : 'inactive'}" role="button" tabindex="0"
                                        onclick="handleButtonClick(this, '${variable.id}', '${association.value}');" 
                                        data-variable-id="${variable.id}"
                                        data-association-value="${association.value}"
                                        style="background-color: ${buttonColor} !important; color: ${getTextColor(variable)} !important; ${isGroupStretched ? '' : `width: ${buttonWidth}px; min-width: ${buttonWidth}px;`}">
                                    ${buttonText}
                                </div>`;
                        });
                        
                        // Für ungruppierte String-Multi-Buttons: horizontale Ausrichtung des Containers entsprechend Einstellung
                        const stringMultiButtonContainerJustify = (!isGrouped) ? `display: flex; justify-content: ${justifyMap}; width: 100%;` : '';
                        content += `
                            <div class="variable-button-container" style="${stringMultiButtonContainerJustify}">
                                <div class="variable-multi-button-container" style="${stringMultiButtonContainerJustify}">
                                    ${buttonsHtml}
                                </div>
                            </div>
                        `;
                        
                    } else {
                        // Fallback für Nicht-Bool/Integer/String-Variablen oder Variablen ohne Associations: Zeige als Text
                        if (variable.variableType === 1) {
                            console.warn('Integer variable', variable.id, 'has no associations for button display. Showing as text.');
                        } else if (variable.variableType === 3) {
                            console.warn('String variable', variable.id, 'has no associations for button display. Showing as text.');
                        } else {
                            console.warn('Button display type only supported for boolean, integer, and string variables. Variable', variable.id, 'is type', variable.variableType);
                        }
                        
                        let textParts = [];
                        
                        if (variable.showLabel && variable.label) {
                            // Doppelpunkt nur hinzufügen wenn auch Value angezeigt wird
                            const labelText = variable.showValue ? `${variable.label}:&nbsp;` : variable.label;
                            textParts.push(`<span class="variable-label" style="color: ${getTextColor(variable)};">${labelText}</span>`);
                        }
                        
                        if (variable.showValue) {
                            textParts.push(`<span class="variable-value variable-text" style="flex: 0 0 auto;">${variable.formattedValue}</span>`);
                        }
                        
                        // Falls nichts konfiguriert ist, zeige Wert als Fallback
                        if (!variable.showLabel && !variable.showValue) {
                            textParts.push(`<span class="variable-value variable-text" style="flex: 0 0 auto;">${variable.formattedValue}</span>`);
                        }
                        
                        content += `<div class="variable-item">
                            ${textParts.join(' ')}
                        </div>`;
                    }
                } else {
                    // Bei Textdarstellung: Label und Wert basierend auf Konfiguration
                    let textParts = [];
                    
                    // Icon für Text-Variablen
                    if (variable.showIcon && variable.icon && variable.icon !== 'Transparent') {
                        const iconClass = prepareIconForDisplay(variable.icon);
                        if (iconClass) {
                            textParts.push(`<i class="${iconClass} variable-icon" style="color: var(--accent-color);"></i>`);
                        }
                    }
                    
                    if (variable.showLabel && variable.label) {
                        // Doppelpunkt nur hinzufügen wenn auch Value angezeigt wird
                        const labelText = variable.showValue ? `${variable.label}:&nbsp;` : variable.label;
                        textParts.push(`<span class="variable-label" style="color: ${getTextColor(variable)};">${labelText}</span>`);
                    }
                    
                    if (variable.showValue) {
                        textParts.push(`<span class="variable-value variable-text" style="flex: 0 0 auto;">${variable.formattedValue}</span>`);
                    }
                    
                    // Falls nichts konfiguriert ist, zeige Wert als Fallback
                    if (!variable.showIcon && !variable.showLabel && !variable.showValue) {
                        textParts.push(`<span class="variable-value variable-text" style="flex: 0 0 auto;">${variable.formattedValue}</span>`);
                    }
                    
                    // Für ungruppierte Text-Variablen: Container richtet bereits aus
                    content += textParts.join('');
                }

                content += `</div>`; // Schließe variable-item div
                
            return content;
        }
        
        function updateVariableCache(list) {
            try { window.variableDataCache = {}; } catch (_) {}
            try {
                const arr = Array.isArray(list) ? list : [];
                for (const v of arr) {
                    const id = (v && (v.variableId || v.id)) ? (v.variableId || v.id) : null;
                    if (id !== null && id !== undefined) {
                        window.variableDataCache[id] = v;
                    }
                }
            } catch (_) {}
        }
        
        // Mini-Update-Funktion für Button-Variablen
        function updateButtonValue(variableId, variable) {
            // Prefer actual button elements to avoid mutating wrappers
            let elements = document.querySelectorAll(`.variable-multi-button[data-variable-id="${variableId}"], .variable-button[data-variable-id="${variableId}"]`);
            if (!elements || elements.length === 0) {
                // Fallback to any node with the data attribute (e.g., wrapper) if no buttons found
                elements = document.querySelectorAll(`[data-variable-id="${variableId}"]`);
            }
            if (!elements || elements.length === 0) {
                return;
            }
            elements.forEach(el => updateButtonDisplay(el, variable));
        }
        
        // Mini-Update-Funktion für Text-Variablen
        function updateTextValue(variableId, variable) {
            // Only target text variable wrappers to avoid altering buttons/images with same variable id
            const nodes = document.querySelectorAll(`.variable-item.text-variable[data-variable-id="${variableId}"]`);
            if (!nodes || nodes.length === 0) return;
            nodes.forEach(node => {
                try {
                    // Update colors and font-size to reflect potential runtime changes
                    const color = getTextColor(variable);
                    if (color) node.style.color = color;
                    if (typeof variable.fontSize === 'number' && variable.fontSize !== -1) {
                        node.style.fontSize = `${variable.fontSize}px`;
                    }

                    // Update label if present
                    const labelEl = node.querySelector('.variable-label');
                    if (labelEl) {
                        const labelText = variable.showValue ? `${variable.label}:\u00A0` : (variable.label || '');
                        labelEl.innerHTML = labelText;
                        labelEl.style.color = color;
                    }

                    // Update value if present
                    const valueEl = node.querySelector('.variable-value');
                    if (valueEl) {
                        const display = (variable.formattedValue !== undefined && variable.formattedValue !== null)
                            ? String(variable.formattedValue)
                            : (variable.rawValue !== undefined && variable.rawValue !== null)
                                ? String(variable.rawValue)
                                : '';
                        valueEl.textContent = display;
                        valueEl.style.color = color;
                    }
                } catch (_) { /* ignore individual node errors */ }
            });
        }
        
        // Cache-Update-Funktion mit korrekter Datenstruktur
        function updateVariableCache(newVariables) {
            if (!window.variableDataCache) {
                window.variableDataCache = {};
            }
            
            // Konvertiere Array-basierte Daten zu ID-basiertem Cache
            for (const arrayIndex in newVariables) {
                const variable = newVariables[arrayIndex];
                const variableId = variable?.variableId || variable?.id;
                
                if (variableId) {
                    window.variableDataCache[variableId] = variable;
                }
            }
        }

        // Funktion zum Animieren aller Progress Bars nach Re-Renders
        function updateProgressBarValue(variableId, newValue) {
            // Locate all matching progress elements (support multiple instances per variable)
            const progressContainers = document.querySelectorAll(`.progress-container[data-variable-id="${variableId}"]`);
            if (!progressContainers || progressContainers.length === 0) return;
            progressContainers.forEach((progressContainer) => {
                const progressBar = progressContainer.querySelector('.progress-bar');
                const progressTextContainer = progressContainer.querySelector('.progress-text');
                if (!progressBar) return;
            
            // Hole Variable-Konfiguration aus Cache
            const variableConfig = window.variableDataCache?.[variableId];
            if (!variableConfig) {
                return;
            }
            
            // Berechne alte und neue Breite
            const minValue = parseFloat(variableConfig.progressMin) || 0;
            const maxValue = parseFloat(variableConfig.progressMax) || 100;
            // KRITISCH: Alte Breite aus dem DOM lesen, NICHT aus dem (soeben aktualisierten) Cache!
            const oldWidth = parseFloat(progressBar.style.width) || 0;
            const newWidth = Math.max(0, Math.min(100, ((newValue - minValue) / (maxValue - minValue)) * 100));
            

            
            // 1. Update cached values for immediate text refresh
            try {
                if (window.variableDataCache && window.variableDataCache[variableId]) {
                    // Ensure cache has the newest raw value
                    window.variableDataCache[variableId].rawValue = newValue;
                    // If not inactive, provisionally update formattedValue to the new raw value for instant UI update.
                    // The proper formatted value (with unit) will override this when its message arrives.
                    const vc = window.variableDataCache[variableId];
                    const shouldShow = vc && (vc.showValue === undefined || vc.showValue === true);
                    if (shouldShow && !(vc && vc.progressbarInactive)) {
                        if (typeof vc.formattedValue === 'undefined' || vc.formattedValue === null) {
                            window.variableDataCache[variableId].formattedValue = String(newValue);
                        }
                    }
                }
            } catch (_) {}

                // 2. Update progress text (if container exists). We rebuild from cached config to keep formatting consistent.
                if (progressTextContainer) {
                    // Temporarily update cached raw/ formatted values if appropriate
                    try {
                        if (window.variableDataCache && window.variableDataCache[variableId]) {
                            // rawValue already updated by caller; formattedValue may be updated separately in same message
                            // Re-render the text from current cache
                            updateProgressText(progressTextContainer, window.variableDataCache[variableId]);
                        }
                    } catch (_) {}
                }
            
                // 3. ANIMATE PROGRESS BAR WIDTH (nur wenn sich Wert geändert hat)
                if (Math.abs(oldWidth - newWidth) > 0.1) {
                    // Setze Bar auf alte Breite
                    progressBar.style.width = oldWidth + '%';
                    progressBar.style.transition = 'none';
                    
                    // Force Reflow
                    progressBar.offsetHeight;
                    
                    // Starte Animation (nur width, keine visuellen Effekte)
                    progressBar.style.transition = 'width 0.5s ease';
                    progressBar.style.width = newWidth + '%';
                    
                    setTimeout(() => {
                        progressBar.style.width = `${newWidth}%`;
                        progressBar.dataset.oldValue = newValue;
                    }, 500);
                }
                
                // Speichere neuen Wert für nächste Animation
                progressBar.dataset.oldValue = newValue;
            });
        }

        function animateProgressBars() {
            const progressBars = document.querySelectorAll('.progress-bar');
            
            // Initialisiere Storage für vorherige Breiten falls nicht vorhanden
            if (!window.previousProgressWidths) {
                window.previousProgressWidths = {};
            }
            
            progressBars.forEach((progressBar, index) => {
                // Finde die Variable ID über das Parent-Element
                const progressContainer = progressBar.closest('.progress-container');
                if (!progressContainer) {
                    return;
                }
                
                const variableId = progressContainer.getAttribute('data-variable-id');
                if (!variableId) {
                    return;
                }
                
                // NEUE Breite aus data-new-width Attribut lesen (nicht aus DOM Style!)
                const newWidthFromData = parseFloat(progressContainer.getAttribute('data-new-width')) || 0;
                
                // ALTE Breite ist die aktuelle DOM-Breite (wurde von Render-Fix gesetzt)
                const oldWidthStyle = progressBar.style.width;
                const oldWidth = parseFloat(oldWidthStyle) || 0;
                

                
                // Nur animieren wenn sich die Breite geändert hat
                if (Math.abs(oldWidth - newWidthFromData) > 0.1) {
                    
                    // DOM ist bereits auf alte Breite gesetzt - KEINE Änderung nötig!
                    // (Der Render-Fix hat das bereits gemacht)
                    
                    // Force Reflow
                    progressBar.offsetWidth;
                    
                    // Aktiviere die CSS transition wieder
                    progressBar.style.transition = 'width 0.5s ease';
                    
                    // Setze die neue Breite - das triggert die Animation
                    progressBar.style.width = newWidthFromData + '%';
                }
                
                // Speichere NEUE Breite für nächstes Mal
                window.previousProgressWidths[variableId] = newWidthFromData;
            });
            

        }

        // Calculate progress bar percentage based on min/max values
        function calculateProgressValue(rawValue, progressMin, progressMax) {
            const minValue = parseFloat(progressMin) || 0;
            const maxValue = parseFloat(progressMax) || 100;
            const currentValue = parseFloat(rawValue) || 0;
            
            const range = maxValue - minValue;
            if (range <= 0) {
                return 0;
            }
            
            const progressValue = Math.max(0, Math.min(100, ((currentValue - minValue) / range) * 100));
            return isNaN(progressValue) ? 0 : progressValue;
        }
        
        // Hilfsfunktion für Progress-Bar-Update
    </script>


</head>

<body>
    <div class="main_container">
        <div id="div1" class="hidden">
            <img id="image" alt="Device Image">
        </div>
        <div class="div2" id="div2">
            <div id="status-container" class="status-container" style="display: none;">
                <!-- Status wird hier angezeigt -->
            </div>
            <div id="variables-container">
                <!-- Dynamische Variablen werden hier eingefügt -->
            </div>
        </div>
    </div>
</body>

</html>
